:description: The what, why and how of the event-data-theory
:navtitle: Event Data Theory
:source-highlighter: highlightjs
// :toc:
:interval-algebra-v: 1.3.0
// TODO: update edm-path to non-sandbox URL
:edm-path: https://docs.novisci.com/edm-sandbox/latest

= A Theory of Event Data

The `event-data-theory` package provides the types and functions
for defining *models* of event data.
The terms "theory" and "model" are borrowed from the notion of a
https://bartoszmilewski.com/2017/08/26/lawvere-theories/[Lawvere theory].
footnote:lawvere[
We use the terms informally
to give the sense that a model of events is an instance of the theory.
We have not checked that the event data theory
actually is a universal algebra.
]

[TIP]
Having a basic understanding how to read Haskell's types
will be useful in reading this document. 

== What is an event

Abstractly, we define an event as an object which contains information about
when something happened and
what something happened.
Concretely, an `+Event+` is a wrapper around the `+interval-algebra+` package's
https://hackage.haskell.org/package/interval-algebra-{interval-algebra-v}/docs/IntervalAlgebra-PairedInterval.html[`PairedInterval` type]:

[source,haskell]
----
include::src/EventDataTheory/Core.hs[tag=eventType]
----

The __what__ part of the pair is a `+Context d c+`, 
which is described further below.
The __when__ part is an `+Interval a+`.
The `Interval` type is described further in 
https://hackage.haskell.org/package/interval-algebra-{interval-algebra-v}/docs/IntervalAlgebra-Core.html[the `+interval-algebra+` documentation].
You can find more information about intervals
and how to use them there.
Since an `+Event+` is an instance of the 
https://hackage.haskell.org/package/interval-algebra-{interval-algebra-v}/docs/IntervalAlgebra-Core.html#t:Intervallic[`+Intervallic+` typeclass],
almost anything you can do with `+Interval+` types
you can also do with `+Event+` types.

=== Event Contexts

An event's `+Context+` contains three types of information: 

[source,haskell]
----
include::src/EventDataTheory/Core.hs[tag=contextType]
----
<1> a set of `+Concepts+`, or tags, 
which can be used to identify events in a collection;
<2> facts about the event whose shape and possible values
are determined by the schema type `d`;
<3> (optionally) data about the provenance of the event in a `+Source+` object.

Filling in and making the type parameters `d` and `c` concrete
is what creates a new event model.
The `Concepts` type `c` will generally be
an ennumerated set of tag variants
(such as `+data MyProjectTags = Diabetes | BirthDay | InHospital | ...+`)
or simply `+Text+`.
Ennumerated tags are preferred over `+Text+`
as users then have some type safety around concepts.
One cannot misspell a concept or use an undefined concept, for example.

The type parameter `d` provides
a high degree of flexibility in defining new event models.
The `d` type represents the schema, or shape, 
of an event's data and
can be a nearly arbitrary type
composed of sum and product types.
Often, the `d` type will be a sum type of "domains"
where each domain is a group of facts relevant to a given domain.
The schema of NoviSci's standard 
{edm-path}/index.html[EDM]
is organized around this idea.

== Marshalling event data

Events are generally produced by some process outside of asclepias
that extracts and transforms a data source into a sequence of events.
NoviSci's standard 
{edm-path}/index.html#_event_representation[EDM]
represents event data 
(plus additional extra information sometimes used in other applications)
as a JSON array, 
where 
http://ndjson.org/[each line]
in a file is a valid `EventLine`.
The `event-data-theory` `+EventLine+` type corresponds to this JSON array
and is used as the primary way of marshalling data into an `Event`.

The `EventDataTheory.EventLines` module provides several utilities
for decoding events from eventlines.
The `parseEventLinesL` function, for example,
converts a `ByteString` of new-line delimed JSON
into a pair of `[String]` (containing any parse error messages)
and `[(SubjectID, Event d c a)]`, 
a list of Subject ID/event pairs. 

== Defining new models

New event models are defined by providing concrete types for `+Event d c a+`
(especially `d` and `c`), 
as in this example from the package's test suite: 

[source,haskell]
----
include::src/EventDataTheory/TheoryTest.hs[tag=exampleEvent]
----

The `+SillyEvent+` type is a synonym for an `Event` where
the concepts are `Text`, 
the facts are of shape `SillySchema`, 
and the `Interval` type is any valid type `a`.

=== Typeclasses for component types

The schema (`d`) type for an `Event` must an instance of
`Eq`, `Show`, `Generic`, and `FromJSON` typeclasses.
The 
https://downloads.haskell.org/ghc/latest/docs/html/users_guide/exts/generics.html?highlight=derivegeneric#extension-DeriveGeneric[`DeriveGeneric`]
language extension makes deriving the `Generic` instance trivial,
as in the code above.
At this time, users do need to provide the `FromJSON` instance,
and the boilerplate in the example above should work in most cases.

The concept (`c`) type for an `Event` must an instance of
`Eq`, `Show`, `Typeable`, and `FromJSON` typeclasses.
Making `c` `Generic` will also make it `Typeable`,
so in most cases simply `deriving (Eq, Show, Generic)` 
and a stock `FromJSON` instance
is sufficient for the concept type.

=== Testing models

The `event-data-theory` packages provides a few utilities for testing
a new model.
These can be found in the `EventDataTheory.Test` module,
which is not included in the main set of exported modules.

The `eventDecodeTests` and `eventDecodeFailTests` functions, for example, test for
successful parsing and successful failed parsing (respectively) 
of `+EventLine d c a+`
into the corresponding `+Event d c a+`.
These functions take a directory path as an argument. 
Each file ending `.jsonl` in that directory should contain
a single `EventLine` as JSON 
to be tested.
See the `test` directory and `EventDataTheory.TheoryTest` module
in this package for examples.
