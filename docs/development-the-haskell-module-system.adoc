:description: This file explains the Haskell module system
:source-highlighter: highlightjs

= The Haskell module system

Gaining familiarity with the Haskell module system 
is helpful in becoming proficient with Hasklepias.
To fully understand how the provided mechanisms work
we will need a basic understanding of Haskell modules
and how they are used to manage namespacing.
The following subsections provide a basic description of the Haskell module system,
but for a complete description please see the following documentation.

* https://www.haskell.org/tutorial/modules.html[Modules] 
in A Gentle Introduction to Haskell.
* https://www.haskell.org/onlinereport/haskell2010/haskellch5.html[Modules] 
in the Haskell 2010 Language Report.

== Haskell module overview

A Haskell program consists of a collection of modules.
The primary purpose of modules is to provide a mechanism for namespacing.
A module is defined as a Haskell declaration and is given a name.
By convention, 
exactly one module is included per file
with the filename sans suffix exactly matching the module name.
So for example, 
if a module was named `Features`, 
then it would be the sole module included in the file `Features.hs`.

Module names are required to be
a sequence of one or more strings beginning with capital letters
and separated by dots with no intervening spaces, 
such as e.g. `Features` or `Cohort.Core`.
The `.` separator is provided to allow package authors to indicate a hierarchy,
however the language itself considers all modules to belong to a flat namespace
(in other words the `.` separators have no effect on the program).
By convention,
a module named `Cohort.Core` would be the sole module declared in the file `Cohort/Core.hs`.

== Haskell module declarations

The standard form of a module declaration is
defined by the keyword `module` followed by the module name,
followed by an optional list of entities enclosed in round parentheses to be exported,
followed by the `where` keyword,
and followed by the module body.
The body consists of 0 or more import declarations,
followed by 0 or more top-level declarations.
So in the following example the module is named `ExampleCohort1`,
the export list has the single entity `exampleCohort1tests`,
and the body consists of two import declarations followed by two top-level declarations.

[source,haskell]
----
-- Module header
module ExampleCohort1
  ( exampleCohort1tests
  ) where

-- Import declarations
import Cohort.Attrition
import Hasklepias

-- Top level declarations
lookback455 :: Integer
lookback455 = 455
----

== Haskell module exports

Each Haskell module can export 0 or more declarations.
Declarations include things like 
data and type declarations, 
class and instance declarations,
type signatures,
function definitions, 
and so on.

Since this section requires some prior knowledge of Haskell to fully understand it
we have included two subsections, 
one which can be read during a first pass, 
and another which can be read at a later time if desired.

=== Haskell module exports: first approximation

Suppose the export list looks like the example shown below.
Loosely speaking this means the following.

1. The `Status` entity is exported.
   The `(..)` syntax can be thought of as meaning 
   "all of the components of the entity."
2. The `makeBaselineFromIndex` entity is exported.
   Many types of entities are just a singular thing 
   and thus the `(..)` syntax is not applicable.
3. The `Cohort.Attrition` module is reexported 
   (this implies that `Cohort.Attrition` is imported somewhere in the module body).

[source,haskell]
----
  ( Status(..)
  , makeBaselineFromIndex
  , module Cohort.Attrition
  )
----

=== Haskell module exports: in more detail

The full export specification is rather involved
so we will not try to cover everything in full detail, 
but rather try to cover the most common cases.
See 
https://www.haskell.org/onlinereport/haskell2010/haskellch5.html#x11-1000005.2[Export Lists]
in the Haskell 2010 Language Report for complete documentation.

* Data types declared using a `data` or `newtype` declaration are
  typically exported by one of the following forms.
  Suppose we have the declaration `data Status = Include | Exclude`.
  Then
** The statement `Status(..)` exports the `Status` data type as well as all of its constructors,
which in this case are `Include` and `Exclude`.
** The statement `Status` exports the `Status` data type but not its constructors
(which makes the data type an `abstract data type`, i.e. you can't construct one "by hand").
* Data types declared using a `type` declaration are exported using the type name.
* Values are exported by providing the value name.
* Classes are typically exported by using the following form.
  Suppose that we have a declared a class `Predicatable` with methods `(|||)` and `(&&&)`.
  Then the form `Predicatable(..)` exports the `Predicatable` class as well as all of its methods,
  which in this case are `(|||)` and `(&&&)`.
  It is also possible to export `Predictable` without exporting all of its method declarations,
  but this is usually not very useful.
* Imported modules can be reexported by using the following form.
  Suppose that we import the module `Cohort.Attrition`, 
  then we can reexport the module using the statement `Module Cohort.Attrition`.

== Haskell module imports

Understanding how Haskell module imports function can be helpful in gaining facility with asclepias
since it enables you to trace back where various entities are defined or created.
At a high level, 
an import serves to add 0 or more entities to the module top-level scope.
A full definition of module imports can be found in 
https://www.haskell.org/onlinereport/haskell2010/haskellch5.html#x11-1010005.3[Import Declarations]
in the GHC documentation.

One concept that module imports provide is
that of _qualified_ and _non-qualified_ imports
(non-qualified imports are usually referred to simply as "imports").
Suppose that we were to specify a qualified import of the `ExampleEvents` module
(see Example 1 below).
This would mean that a given entity
exported from within `ExampleEvents`
has to be referred to via the `ExampleEvents` namespace.
So if for example `ExampleEvents` exports an entity `exampleEvents1`, 
then the default syntax to refer to this entity would be `ExampleEvents.exampleEvents1`.
There is also a way to specify an alternative name for the namespace such as `EE`
instead of ExampleEvents to make it more convenient to use within the module
(see Example 2 below).
On the other hand, 
a non-qualified import would simply
place all of the exported entities
from ExampleEvents into the top-level scope
(see Example 3 below).
In that case you can just refer to `exampleEvents1` directly.

The module import system also allows you
to import a subset of the exported entities from a given module.
To do this you can either
provide a list of entities to include from the module exports 
(see Example 4 below),
or conversely
you can provide a list of entities to remove from the module exports 
(see Example 5 below).

Some examples of various forms of module imports are shown below.
Note that each of these examples would be expected to come from different module declarations.

[source,haskell]
----
-- Example 1. All exported entities from `ExampleEvents` are available in the
-- module, but must be referred to through the `ExampleEvents` namespace
import qualified ExampleEvents
----
[source,haskell]
----
-- Example 2. All exported entities from `ExampleEvents` are available in the
-- module, but must be referred to through the `EE` namespace
import qualified ExampleEvents as EE
----
[source,haskell]
----
-- Example 3. All exported entities from `ExampleEvents` are added to the
-- top-level scope
import ExampleEvents
----
[source,haskell]
----
-- Example 4. Add only `exampleEvents1` and `exampleEvents2` to the top-level
-- scope
import ExampleEvents (exampleEvents1, exampleEvents2)
----
[source,haskell]
----
-- Example 5. Add everything but `exampleSubject1` and `exampleSubject2` to the
-- top-level scope
import ExampleEvents hiding (exampleSubject1, exampleSubject2)
----
