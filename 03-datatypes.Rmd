# Data Types

The data types formalized here will mostly be familiar to epidemiologists.

## Interval

An interval $\Xi$ is as an ordered pair defining the start and end of a segment on the integer line.

\[
\Xi := (a, b) \mid a \leq b \in \mathbb{Z}
\]

Let $\mathcal{I}$ be the set of all $\Xi$. Here's a few $\Xi$s represented visually:

```{r, echo = FALSE, fig.height = 1}
num_line_baseplot <- function(a, b){
  ggplot() + 
    geom_blank() + 
    scale_x_continuous(
      limits = c(a - 1, b + 1),
      expand = c(0, 0),
      breaks = function(l) seq(l[1] + 1, l[2] - 1, by = 1)
    ) + 
    theme_minimal() + 
    theme(
      panel.grid  = element_blank(), 
      axis.line.x = element_line(size = 0.5, color = "black", 
                                 arrow = arrow(ends = "both", 
                                               length = unit(0.2, "npc"))),
      axis.ticks.x = element_line(size = 0.25),
      axis.title   = element_blank(),
      axis.text.y  = element_blank()
    )
}

dt <- tibble::tibble(
  a = c(-1, -1, 2, 5),
  b = c(0, 3, 10, 5),
  y = c("0", "1", "2", "3")
)

num_line_baseplot(-2, 10) + 
  geom_segment(
    data = dt,
    aes(x = a, xend = b, y = y, yend = y),
    lineend = "round"
  ) + 
  geom_point(
    data = dt,
    aes(x = b, y = y), color = "red"
  ) +
  geom_point(
    data = dt,
    aes(x = a, y = y), color = "blue"
  ) 
```

To make the math concrete, define data structures in a programming language (in this case `R`) that align with our mathematical definition.

```{r}
itv <- interval(a = 2L, b = 4L)
itv
```

We're going to get into functions later, but a few basic functions might help contextualize what we can do with the interval data structure.
 
| Definition     | Mapping                      | Description        |
| ------------   | ---------------------------- | ------------------ |
| $s(\Xi) = a$ | $s : \mathcal{I} \mapsto \mathbb{Z}$ | Gets the interval's start | 
| $e(\Xi) = b$ | $e : \mathcal{I} \mapsto \mathbb{Z}$ | Gets the interval's end   |
| $shift(\Xi, c) = (s(\Xi) + c, e(\Xi) + c)$ | $shift : (\mathcal{I}, \mathbb{Z}) \mapsto \mathcal{I}$ | Shifts an interval by $c$ |
| $expandl(\Xi, c) = (s(\Xi) - c, e(\Xi))$ | $expandl : (\mathcal{I}, \mathbb{Z}) \mapsto \mathcal{I}$ | Expands an interval to the left by $c$ | 
| $expandr(\Xi, c) = (s(\Xi), e(\Xi) + c)$ | $expandr : (\mathcal{I}, \mathbb{Z}) \mapsto \mathcal{I}$ | Expands an interval to the right by $c$ | 
| $expand(\Xi, c) = (s(\Xi) - c, e(\Xi) + c)$ | $expand : (\mathcal{I}, \mathbb{Z}) \mapsto \mathcal{I}$ | Expands an interval by $c$ | 
| $length(\Xi) = e(\Xi) - s(\Xi)$ | $length : \mathcal{I} \mapsto \mathbb{Z}$ | Measures the length of an interval | 
| $flipl(\Xi)  = (s(\Xi) - length(\Xi), s(\Xi))$| $flipl : \mathcal{I} \mapsto \mathbb{Z}$ | Flips an interval to the left | 
| $flipr(\Xi)  = (e(\Xi), e(iota) + length(\Xi))$| $flipr : \mathcal{I} \mapsto \mathbb{Z}$ | Flips an interval to the right | 
| $ennummerate(\Xi) = \{z \mid z \in \mathbb{Z}, z >= s(\Xi), z <= e(\Xi)\}$ | $ennummerate : \mathcal{I} \mapsto \mathbb{Z}$ | Ennumerates all the integers in an interval |
| $=(\Xi, \Xi') = \begin{cases} TRUE  & s(\Xi) = s(\Xi') \; \& \; e(\Xi) = e(\Xi') \\ FALSE & else\end{cases}$ | $= : (\mathcal{I}, \mathcal{I}) \mapsto \mathbb{B}$ | determines if two intervals are equal$ | 
| $<(\Xi, \Xi') = \begin{cases} TRUE  & s(\Xi) < s(\Xi') \\ TRUE  & s(\Xi) = s(\Xi') \; \& \; e(\Xi) < e(\Xi') \\ FALSE & else\end{cases}$ | $< : (\mathcal{I}, \mathcal{I}) \mapsto \mathbb{B}$ | determines if two intervals are ordered such that $s(\Xi) < s(\Xi')$ or $s(\Xi) = s(\Xi')$ and $e(\Xi) < e(\Xi')$. | 
| $order( ( \Xi, \Xi' ) ) = \begin{cases} <\Xi, \Xi'>  & <(\Xi, \Xi') = TRUE \\ < \Xi', \Xi > & <(\Xi, \Xi') = FALSE \end{cases}$ | $order : (\mathcal{I} \times \mathcal{I}) \mapsto \mathcal{I^{2}_o}$ where $\mathcal{I}^{2}_o = \{ < \Xi, \Xi' >\}$ and $<\cdot, \cdot>$ indicates that the pair of elements are ordered | puts two intervals into order according to `<`.| 
| $overlaps( <\Xi, \Xi'> ) = \begin{cases} TRUE  & s(\Xi') \leq e(\Xi) \\ FALSE & else\end{cases}$ | $overlaps : \mathcal{I^{2}_o} \mapsto \mathbb{B}$  | determines if two ordered intervals overlap | 

These functions may seem trivial, but they reveal a few concepts:

* We've expressly defined the data types of each function's input and output.
* Starting with simple accessor functions ($s$ and $e$) and basic set, relational, and arithmetic operators, we created simple functions from which more complicated functions can be composed (as we will see). 




Here are the functions in action:

```{r, error = TRUE}
itv <- interval(a = 2L, b = 10L)
s(itv)
e(itv)
ennummerate(itv)
length(itv)
flipl(itv)
flipr(itv)
shift(itv, 5L)
expandl(itv, 5L)
expandr(itv, 5L)
expand(itv, 5L)
itv < interval(a = 5L, b = 11L)
itv < interval(a = 1L, b = 11L)
itv < interval(a = 2L, b = 11L)
itv < interval(a = 2L, b = 3L)

interval_pair(a = itv, b = interval(a = -1L, b = 10L)) %>%
  order() %>%
  overlaps()

interval_pair(a = itv, b = interval(a = -1L, b = 0L)) %>%
  order() %>%
  overlaps()


interval_pair(a = itv, b = interval(a = 2L, b = 11L)) %>%
  order() %>%
  overlaps()
```

## Context

Define a context $\square$ as an arbitrary, finite collection of objects. A context is always paired with a $\Xi$ as an event (defined below) and contains all the relevant information about the $\Xi$ such as a type and associated values.

For the purposes of this demonstration, let the context be the pair the suit and value of a poker card:

\[
\square \in \{suit \in \mathcal{S} = \{\clubsuit, \heartsuit, \diamondsuit, \spadesuit \}, value \in \mathcal{V} = \{A, 2, 3, 4, 5, 6, 7 , 8, 9, 10, J, Q, K\}\}
\]

Let $\overline{\square}$ be the set of all contexts specific to our study.

Define a couple of accessor functions for our specific context:

| Definition      | Mapping                      | Description        |
| ------------    | ---------------------------- | ------------------ |
| $suit(\square)$ | $suit : \overline{\square}\ \mapsto \mathcal{S}$ | Gets the suit of a context. |
| $value(\square)$ | $value : \overline{\square}\ \mapsto \mathcal{V}$ | Gets the value of a context |

```{r}
c1 <- context(suit = suit("heart"), value = "3")
c2 <- context(suit = suit("diamond"), value = "J")

suit(c1)
suit(c2)
value(c1)
value(c2)
```

## Contextualized Set

This pattern repeats throughout the design:

$$
\{ \square, \cdot \}
$$
where $\cdot$ is some set.

TODO: further describe this type.


## Events

The fundamental data structure in this setup is that of events occurring in time with information attached to the event such as a hospital stay, disease diagnosis, or lab values. We most often work on the time scale of days, so for now we'll think about the time intervals in terms of integers.

Define an event $w$ as a set with an interval and a context:

\[
w := \{\Xi, \square\}
\]

```{r}
event(interval = itv, context = c1)
event(interval = interval(a = 4L, b = 20L), context = c2)
```

## Event History

Events are collected into an indexed, partially ordered set:

\[
W = \{ (w_1, w_2, \dots, w_n) \mid  \Xi_i \leq \Xi_{i + 1} \: \forall i = 1, \dots, n -1 \}
\]

Here's a randomly generated set $W$:

```{r, echo = FALSE}
set.seed(12)
n <- 20
W <- tibble::tibble(
  x     = sample(1L:100L, size = n, replace = TRUE),
  y     = x + sample(0L:10L, size = n, replace = TRUE, prob = c(.5, rep(.05, 10))),
  suit  = sample(c("heart", "club", "spade", "diamond"), size = n, replace = TRUE),
  value = sample(c("A", "2", "3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K"),
                 size = n, replace = TRUE)
) 

Wdt <- W %>%
  mutate(
    xy       = purrr::map2(x, y, ~ c(.x, .y)),
    interval = purrr::map2(x, y, ~ interval(a = .x, b = .y)),
    context  = purrr::map2(suit, value, ~ context(suit = suit(.x), value = .y))) %>%
  dplyr::arrange(x, y)

W <- apply(select(Wdt, interval, context), 1, as.event)
cat(paste0(Map(function(x) as.character(x), W), collapse = ",\n"))
```

And here's $W$ represented graphically where y-axis is used to differentiate each $w$ by its suit:

```{r, echo = FALSE, fig.height=3}
ggplot(
  data = select(Wdt, x, y, suit, value),
  aes(x = x, y = suit)
) + 
  geom_segment(
    aes(xend = y, yend = suit),
    color = "grey90", size = 0.5) +
  geom_point(
    aes(shape = suit),
    size = 5, position = position_dodge(width = 0.8) ) + 
  geom_text(
    aes(x = x, y = suit, label = value),
    size = 5, nudge_y = 0.3) + 
  scale_shape_manual(
    guide  = FALSE,
    values = c("spade"= "\u2660", "heart" = "\u2665", 
               "club" = "\u2663", "diamond" = "\u2666")
  ) +
  # scale_y_discrete(expand = c(0, 0)) + 
  theme_classic() +
  theme(
    axis.line.x = element_line(size = 0.5, color  = "black"),
    axis.ticks.x = element_line(size = 0.5),
    axis.title   = element_blank(),
    axis.text.y  = element_blank()
  )
```

## Subject

A subject, patient or unit is a context and an event history:

$$
U = \{ \square, W\}
$$

## Population

A population is a context and a unordered set of subjects:

$$
P = \{\square, \{U_1, \dots, U_m \} \}
$$

TODO:

* define a way of ordering populations?
