:toc: left

= `monarch`, a prototype
`monarch` is a tool for specifying test routines via csv, geared toward `asclepias` users. Currently it is a prototype, a starting point for discussion about what functionality `asclepias` users would like from such a tool and about how best to design a text-based user interface.

== Features

. Given a function mapping some user-defined Haskell types `input` to `output`, allows the user to specify in `csv` format some data to provide as input and the expected output. `monarch`: 
  .. converts the `csv` data to the appropriate types, 
  .. runs the function on the inputs, 
  .. compares the function result to the outputs via a testing framework,
  .. reports results.
.  Uses a subset of the Dhall configuration language and its `dhall-csv` interpreter. Each cell value must be parseable as one of the following types:
  .. `Text`
  .. `Integer`
  .. `Natural`
  .. `Double`
  .. `Bool` 
  .. a user-defined sum type with at most one value of the types listed above in each variant, e.g. `This | That Integer` in Haskell or Dhall syntax.
  .. a user-defined type that simply wraps one of the types above, e.g. `newtype Thing = MkThing Integer`.
. Provides ready-to-use conversions from the flat `csv` format for the core `asclepias` types defined in `event-data-theory`, such as `Event`:
  .. project-specific types that are special cases of the `event-data-theory` types need only specify the function from `input` to `output`,
  .. along with a schema dictating the concrete types used for values, e.g. `Text` for the `Context` values of an `Event`.
. For non-standard types, allows users to define how the flat `csv` data must be marshalled into the `input` and `output` types to be tested.
. Conversions to the appropriate internal types for supported custom types, such as newtype wrappers or sum types, can be provided automatically by `deriving Generic` and specifying `instance FromDhall` in the project's Haskell code.


== Non-features

. Users currently must specify input and output csv files associated with each test routine, with no helpers or naming conventions to read those files automatically from the filesystem.
. Does not allow the user to derive the flat-format-to-Haskell conversion generically for arbitrary Haskell types. These must be implemented by hand for any type not among those `monarch` implements itself, and only those that can be flattened and marshalled via `dhall-csv` are supported.
. Does not support csv cell-value types that are recursive or containers, e.g. lists.
. Is not a programming language and for example does not support functions as text input.
. Only supports single-element `Concepts` sets within the `Context` and `Event` types of `event-data-theory` because of a limitation in `dhall-csv`.
. Golden tests, in which expected and actual outputs are compared as text files, are the only ones implemented. It would be simple to extend support to unit tests, and possible with some work to extend support for property-based tests.


== How-to, with pre-defined types
This walks through how to run a test with `monarch` when the project types are special cases of those in `event-data-theory`. The full code is in the `Examples.Simple` module, which can be run from the `asclepias` repo with `cabal run monarch`.

=== Set-up
This section is a dummy setup for a project using `asclepias`. The code is not `monarch`-specific.

Suppose you have the following input types
[source,haskell]
----
data TrueFacts = Awesome | NotAwesome Text deriving (Show, Eq, Generic)
type ProjEvent = Event Text TrueFacts Integer
type Index = Interval Integer
----

where `Event c m a` is defined in `EventDataTheory.Core`. An `Event` is an `Interval` (from `interval-algebra`) with some `Context` type meta-data. For example, 

[source,haskell]
----
f1 :: TrueFacts
f1 = Awesome

c1 :: Concepts Text
c1 = packConcepts ["yay"]

e1 :: ProjEvent
e1 = event (beginerval 0 1) (context c1 f1 Nothing)
----

prints as an `Event` with interval `(1, 2)` and a `Context` with contained `Contepts` of type `Text` with value `"yay"`, a facts field of type `TrueFacts` and value `Awesome`, and `Nothing` in the source field.

----
MkEvent {(1, 2), MkContext {getConcepts = MkConcepts (fromList [MkConcept "yay"]), getFacts = Awesome, getSource = Nothing}}
----

Our output type is defined as 

[source,haskell]
----
data SumminElse = WasBefore | WasAfter deriving (Show, Eq, Generic)
type ProjOccurrence = Event Text SumminElse Integer
----

Our 'cohort-building' routine that we want to test, call it `cohortBuilder`, will take a list of `ProjEvent` and check whether the endpoints of the contained intervals are after the endpoint of the `index` interval, `(0, 1)`. `cohortBuilder` will return the input intervals with their facts field changed to type `SumminElse`, with value `WasAfter` if so and `WasBefore` otherwise.

For example, 
[source,haskell]
----
index :: Index
index = beginervalMoment 0

e1Out :: [ProjOccurrence]
e1Out = cohortBuilder index [e1]
----

gives 

----
[MkEvent {(1, 2), MkContext {getConcepts = MkConcepts (fromList [MkConcept "yay"]), getFacts = WasAfter, getSource = Nothing}}]
----
