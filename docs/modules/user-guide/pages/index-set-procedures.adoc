:description: The procedure for creating an IndexSet 

An IndexSet represents the set of all index dates for an event.
asclepias requires a function defining how to create the IndexSet
from the input data.

*Creating an IndexSet from an Event*

If indices are required for your project,
and your input data is in `Event` format
then you must define a function that takes in a list
of `Event` s, with defined `t` agSet, `m` odel, and `Interval a` types
and returns an `IndexSet` of `Interval a` types.
Instructions on defining `t` and `m` are given later.

The following index function takes in a list of `Event` s
and creates an `IndexSet` where the index is defined as
the last day that `YOUR_TAG` occurred for longer than 1 temporal unit (`a`)
during `yourStudyPeriod`.

[source,haskell]
----
index :: [Event t m a] -> IndexSet (Interval a)
index events =
  events
    |> filterEvents (containsTag [YOUR_TAG])
    |> combineIntervals
    |> filter
         (getPredicate
           (Predicate ((> 1) . duration) &&& Predicate (concur yourStudyPeriod))
         )
    |> fmap (endervalMoment . end)
    |> into
----

Update `a` with the type of your input data temporal values (Day, UTCTime, Int, etc.).

*TODO add an example of creating an index set with more than one date*

*Creating an IndexSet from a list*

If your project's InputData is not in `Event` format,
but is in `EventLine` format,
then you can create an index set using `makeIndexSet`.
*TODO not sure this is true*
*I'm not sure the relationship between eventLines and Events*

[source,haskell]
----
data EventLine t m a = MkEventLine Value Value Value Value [t] (FactsLine m a) 
  deriving (Eq, Show, Generic)

newtype Event t m a = MkEvent ( PairedInterval (Context t m) a ) 
  deriving (Eq, Show, Generic)
----

`makeIndexSet` takes in a list of intervals to produce an IndexSet.

*TODO shouldn't `i` be an interval? where do we guarantee that?*

[source,haskell]
----
makeIndexSet :: (Ord i) => [i] -> IndexSet i
makeIndexSet = into
----

*TODO can we use the same sytax with EventLines as we do with Events?*

[source,haskell]
----
index :: [EventLine t m a] -> IndexSet (Interval a)
index events =
  events
    |> filterEvents (containsTag [YOUR_TAG])
    |> combineIntervals
    |> filter
         (getPredicate
           (Predicate ((> 1) . duration) &&& Predicate (concur yourStudyPeriod))
         )
    |> fmap (endervalMoment . end)
    |> into
----

Update `a` with the type of your input data temporal values (Day, UTCTime, Int, etc.).

*Creating an empty IndexSet*

If no indices are required for your study,
you must still create an IndexSet
as this is a requirement for `CohortSpec`.
You can define an empty IndexSet as follows:
[source,haskell]
----
emptyIndex :: YourInputDataType -> IndexSet ()
emptyIndex _ = makeIndexSet [()]
----
Update `YourInputDataType` with your project-specific input data type.

