= Find durations of time that satisfy multiple conditions

This example demonstrates

* [x] reasoning with the interval algebra
* [x] manipulating intervals
* [x] using concepts to group events

In this example,
the goal is to write a function that,
given a pair of lists of concepts and
an interval of time: 

* filters an input list of events to those that concur with the given interval
* splits the events into those with the first concepts and those with the second
* returns the start of the last event of the first setof concepts where
it occurs within +/- 3 time units of an event of the second set of concepts.

[TIP]
A function like this could be useful
for defining an index event where the index 
needs to occur with a time window of other events.

[source,haskell]
----
include::DurationsWithMultipleConditions.hs[tag=function]
----

Take the case that a subject has the following events,
and we want to know the first time when a diagnosis
occurred within +/- 3 days of a procedure.
Our given interval, called `Baseline` here,
is (6, 15).
Below, we walk through the function step-by-by using this case.

----
      ---------                <- Baseline
    -                          <- [pr]
      -                        <- [pr]
          -                    <- [dx]
            -                  <- [pr]
            ----               <- [foo]
------------------------------
----

<1> Filter events to those concurring
with the given interval.
+
----
      ---------                <- Baseline
      -                        <- [pr]
          -                    <- [dx]
            -                  <- [pr]
            ----               <- [foo]
------------------------------
----

<2> Form a pair of lists where the first element
has `c1` (dx in our example) events and
the second has `c2` (pr in our example) events.
Any events without `c1` or `c2` concepts are dropped.
In the running example, 
the intervals of the events would make the 
following pair:
+
----
( [(10,11)] -- the dx event
, [(6,7), (12,13)] -- the pr events
)
----

<3> Form a list of all pairs of events
from the previous step.
+
----
[ ( (10,11), (6,7) )
, ( (10,11), (12,13) ) 
]
----

<4> Filter this list of pairs to cases where a `c1` event concurs
with a `c2` event after
`c2` event intervals have been expanded by +/- 3 units of time.
The list from the last step gets converted to:
+
----
[ ( (10,11), (3,10) )
, ( (10,11), (9,16) ) 
]
----
And then filtered to:
+
----
[ ( (10,11), (9,16) ) ]
----

<5> Take `Just` the last element of the list, if it exists.
Otherwise, `Nothing`.

<6> If it exists, take the `begin` of the last `c1` interval.
In our example, this is `Just 10`.

Lastly, the example function can be lifted into a `Definition` using
the `define` function:

[source,haskell]
----
include::DurationsWithMultipleConditions.hs[tag=definition]
----

