:doctype: book
:toc: left
:source-highlighter: highlightjs
:sourcedir: ../src

:ghcVersion: 8.10.6
:hlsVersion: 1.2.0
:cabalVersion: 3.4.0.0

= The Book of Asclepias

== Getting Started with `Hasklepias`

`Hasklepias` is an embedded domain specific language (eDSL) written in https://www.haskell.org/[Haskell] library. To get started, then, you'll need to install the Haskell toolchain, especially the https://www.haskell.org/ghc/[Glasgow Haskell Compiler] (GHC) and the building and packaging system https://www.haskell.org/cabal[cabal], for which you can use the https://www.haskell.org/ghcup[`ghcup` utility].

You can use any development environment you choose, but for maximum coding pleasure, you should install the https://github.com/haskell/haskell-language-server[Haskell language server] (`hsl`). This can be installed using `ghcup` or some integrated development environments, such as https://code.visualstudio.com/[Visual Studio Code], have https://marketplace.visualstudio.com/items?itemName=haskell.haskell[excellent `hsl` integration].

In summary,

. Install https://www.haskell.org/ghcup[`ghcup`].
+
----
curl --proto '=https' --tlsv1.2 -sSf https://get-ghcup.haskell.org | sh
----
. Inspect your toolchain installation using `ghcup list`. You will need `ghc` ({ghcVersion}) , `hls` ({hlsVersion}), and `cabal` ({cabalVersion}) installed.
. Upgrade toolchain components as necesarry. For example:
+
----
ghcup install ghc {ghcVersion}
ghcup set ghc {ghcVersion}
ghcup install cabal {cabalVersion}
ghcup set cabal {cabalVersion} 
----
. Setup your IDE. (e.g. in Visual Studio, you'll want to install the https://marketplace.visualstudio.com/items?itemName=haskell.haskell[Haskell] extension.

== A Brief Lesson in Haskell

Since `Hasklepias` is written in https://www.haskell.org/[Haskell], you'll need to understand the syntax of Haskell function and a few concepts. The Haskell language is over 30 years old and has many, many features. In this section, we introduce the ideas and syntax necessary to be productive when using `Hasklepias`.

=== Haskell resources

* http://learnyouahaskell.com/chapters[Learn You a Haskell for Great Good!]: good intro text
* https://www.cs.nott.ac.uk/~pszgmh/pih.html[Programming in Haskell]: excellent intro text
* http://dev.stephendiehl.com/hask/[What I wish I knew when learning Haskell]: excellent resource
* https://gist.github.com/graninas/833a9ff306338aefec7e543100c16ea1[Haskeller competency matrix]
* https://hoogle.haskell.org/[Hoogle]: search engine for Haskell functions
* https://www.youtube.com/watch?v=hZgW4mT1PkE[5 years of Haskell in production]: video on using Haskell in production environment
* https://williamyaoh.com/posts/2020-04-12-software-engineer-hangups.html[Things software engineers trip up on when learning Haskell]: a software engineer's list of tips on using Haskell


=== Purely Functional and Statically Typed

Haskell is a purely functional programming language. All functions are https://en.wikipedia.org/wiki/Function_(mathematics)[functions in a mathematical sense]; they relate a set of inputs to a set of outputs. As many languages today include many ideas of functional programming, you may be familiar with programming in a functional style. You may not be familiar with a language where writing and composing functions is the *only* thing you can do. Moreover, Haskell is statically typed, meaning that all expressions have a type that can be determined when a program is compiled. To understand functions and types, let's look at example syntax:

[source,haskell]
----
add :: Integer -> Integer -> Integer <1>
add x y = x + y <2>
----

<1> This is the type signature. The `add` function's type signature tells us `add` takes two `Integer` as inputs and returns an `Integer`. The last element in the chain of arrows is the return type. The type signature is not strictly necessary in order to compile a program, as GHC will try to infer the types; however, the type signature is *invaluable* in understanding the types that a function can act on and what it returns.
<2> This is the definition of the `add`: take the value of `x` (an `Integer`) and add it to the value of `y` (also an `Integer`).

If you coming from a dynamically typed language, static types may feel limiting at first: shouldn't you just be able to write a function and run your program? In R, for example, you might write the `add` function simply as: 

[source,R]
----
addR <- function(x, y){ x + y }
----

When you run `addR("1", 1)`, you get a *run-time* error: `Error in x + y : non-numeric argument to binary operator`. In Haskell, however, running `add "1" 1` *isn't even possible*. The compiler will tell you:

----
Couldn't match expected type ‘Integer’ with actual type ‘[GHC.Types.Char]’
----

As programs grow in size, the type checker is like having a astute programming buddy helping you avoid writing bad programs.  

=== Interactive environment (GHCi)

To run the examples interactively, open a `ghci` session with:

[source,shell]
----
cabal repl hasklepias:examples --repl-options -itest
----

The option flag `--repl-options -itest` allows to make changes to the files in the `examples` folder and reload with `:reload` (or `:r`) without exiting the `ghci` session. Developers working on `src` files can add the `--repl-options -isrc` option flag to make changes to `src` files too.

In `ghci` you have access to all exposed functions in `hasklepias`, `interval-algebra`, and those in the `examples` folders. For example, `exampleEvents1` is a list of events used to check some of the example features, which you can interact with:

[source,shell]
----
*Main> headMay exampleEvents1
Just {(1, 10), Context {getConcepts = ["enrollment"], getFacts = Nothing, getSource = Nothing}}
*Main> length exampleEvents1
24
*Main> combineIntervals $ intervals exampleEvents1
[(1, 10),(11, 20),(21, 30),(31, 40),(45, 100)]
*Main> mapM_ print exampleEvents1
{(1, 10), Context {getConcepts = fromList ["enrollment"], getFacts = Nothing, getSource = Nothing}}
{(2, 3), Context {getConcepts = fromList ["wasScratchedByCat"], getFacts = Nothing, getSource = Nothing}}
{(5, 6), Context {getConcepts = fromList ["hadMinorSurgery"], getFacts = Nothing, getSource = Nothing}}
{(5, 10), Context {getConcepts = fromList ["tookAntibiotics"], getFacts = Nothing, getSource = Nothing}}
{(11, 20), Context {getConcepts = fromList ["enrollment"], getFacts = Nothing, getSource = Nothing}}
{(21, 30), Context {getConcepts = fromList ["enrollment"], getFacts = Nothing, getSource = Nothing}}
{(31, 40), Context {getConcepts = fromList ["enrollment"], getFacts = Nothing, getSource = Nothing}}
{(45, 46), Context {getConcepts = fromList ["wasStruckByDuck"], getFacts = Nothing, getSource = Nothing}}
<<<result truncated>>>
----


=== A few basic functions worth knowing

.Function Application (`$`)

The `$` can be useful for omitting parentheses. For example,
[source,haskell]
----
f $ g $ h x  =  f (g (h x))
----

.`curry`/`uncurry`

Every function in Haskell is https://wiki.haskell.org/Currying[*curried*]. In other words, continuing our `add` example, applying `add` to a single argument returns another unnamed function of a single argument: 

[source,haskell]
----
add 1 = \y -> y + 1
----

Sometimes you want a function that takes a single pair as input rather than two inputs. This is done by `uncurry`: 

[source,haskell]
----
uncurry :: (a -> b -> c) -> ((a, b) -> c)
uncurry f p = f (fst p) (snd p)
----

For example: 
[source,haskell]
----
add' :: (Integer, Integer) -> Integer
add' = uncurry add 

myVal = add' (1, 2)
----

The `curry` function is the inverse of `uncurry`, taking a function that takes a single pair into a function of two arguments.

.Pipe operator

The pipe operator (`|>`) is not really idiomatic Haskell. It comes from the https://hackage.haskell.org/package/flow:[`flow`] library. But since most Hasklepias users will come from a data science background and may have seen a lot of R code that uses pipes (either `%>%` or `|>` (after R 4.0.1)), the `|>` is provided in Hasklepias and is used often in the examples. The `|>` can simply be read as "and then", as in `x |> g |> f` reads "take x and then do g and then do f."

== Setting up a Hasklepias Project

=== Initialize a new Haskell project

[source,haskell]
----
PROJID=myProj
cabal init --libandexe --application-dir=apps --source-dir=plans --package-name=$PROJID -m -u https://gitlab.novisci.com/nsResearch/$PROJID -d hasklepias 
cabal update
----

. Rename `MyLib.hs` to `Cohorts.hs`. Add header.
. Add submodules for each group cohorts.
. Update `myProj.cabal`
.. expose all modules
.. set `hasklepias` to a particular version
.. set library default extensions:
+
----
 default-extensions: 
   NoImplicitPrelude
   OverloadedStrings
   LambdaCase
   DataKinds
   FlexibleContexts
   MultiParamTypeClasses
----
. Start coding.

=== Establish a build framework

== Working with a Hasklepias Project

=== Interval Algebra and Events

=== Defining Features

The `Feature` type, and its corresponding `Definition` type, are the basic building blocks for defining cohorts. You can think of `Feature` s as "variables", but they are more abstract than a simple column vector, for example. To explain, let's look at the `Feature` type definition:

[source,haskell]
----
include::{sourcedir}/Features/Compose.hs[tag=feature]
----

A `Feature` is a type parametrized by two types: `name` and `d`. The type `d` here stands for "data", which then parametrizes the `FeatureData` type which is the singular value which a `Feature` contains. The `d` here can be almost anything and need not be a scalar, for example,  `Int`, `Text`, `(Int, Maybe Text)` and `[Double]` are all valid types for `d`. The `name` type a bit special: it does not appear on the right-hand side of the `=`. In Haskell parlance, `name` is a https://wiki.haskell.org/Phantom_type[phantom type]. We'll see in a bit how this can be useful. For now, think of the `name` as the name of a variable as you would in most programming languages. To summarize, a `Feature` 's type constructor takes two arguments (`name` and `d`), but its *value* constructor (`MkFeature`) takes a single value of type `FeatureData d`.

Values of the `FeatureData` type contain the data we're ultimately interested in analyzing or passing along to downstream applications. However, a `FeatureData` value does not simply contain data of type `d`. The type allows for the possibility of missingness, failures, or errors by using the https://hackage.haskell.org/package/base-4.15.0.0/docs/Data-Either.html:[`Either` type]:

[source,haskell]
----
include::{sourcedir}/Features/Compose.hs[tag=featureData]
----

A value of a `FeatureData`, then, is either a `Left MissingReason` or `Right d` where `MissingReason` can be one of:

[source,haskell]
----
include::{sourcedir}/Features/Compose.hs[tag=missingReason]
----

The use of `Either` has important implications when defining Features, as we will see. Now that we know the internals of a `Feature`, how do we create `Feature` s? There are two ways to create features: (1) `pure` ly lifting data into a `Feature` or (2) writing a function that `define` s a `Feature` based on other `Feature` s. 

The first method is a way to get data directly into a `Feature`. the following function takes a list of `Events` and makes a `Feature` of them:

[source,haskell]
----
allEvents :: [Event Day] -> Feature "allEvents" [Event Day]
allEvents = pure
----

The `pure` lifting is generally used to lift a subject's input data into a `Feature`, so that other features can be defined from a subject's data. `Feature` s are derived from other `Feature` s by the `Definition` type. Specifically, `Definition` is a type which contains a function which maps `Feature` inputs to a `Feature` output, for example:

[source,haskell]
----
myDef :: Definition (Feature "a" Int -> Feature "b" Bool)
myDef = define (\x -> if x > 0 then True else False)
----

A `Definition` is created by the `define` (or `defineA`) function. One may ask why `define` is necessary, and we don't directly define the function (`Feature "a" Int -> Feature "b" Bool`) directly. What may not be obvious in the above, is that `x` is type `Int` not `Feature "a" Int` and the return type is `Bool` not `Feature "b" Bool`. The `define` function and `Definition` type do the magic of lifting these types to the `Feature` level. To see this, in the following, `myDef2` is equivalent to `myDef`: 

[source,haskell]
----
intToBool :: Int -> Bool
intToBool x = if x > 0 then True else False)

myDef2 :: Definition (Feature "a" Int -> Feature "b" Bool)
myDef2 = define intToBool
----

The `define` function, then, let's us focus on the *logic* of our `Feature` s without needing to worry handling the error cases. If we were to write a function with signature `Feature "a" Int -> Feature "b" Bool` directly, it would look like:

[source,haskell]
----
myFeat :: Feature "a" Int -> Feature "b" Bool
myFeat (MkFeature (MkFeatureData (Left r))) = MkFeature (MkFeatureData (Left r))
myFeat (MkFeature (MkFeatureData (Right x))) = MkFeature (MkFeatureData (Right $ intToBool x))
----

One would need to pattern match all the possible types of inputs, which gets more complicated as the number of inputs increases. As an aside, since `Feature` s are https://hackage.haskell.org/package/base-4.15.0.0/docs/Data-Functor.html:[Functors], one could instead write:

[source,haskell]
----
myFeat :: Feature "a" Int -> Feature "b" Bool
myFeat = fmap intToBool
----

This would require understanding how Functors and similar structures are used. The `define` and `defineA` functions provide a common interface to these structure without needing to understand the details.

==== Evaluating Definitions

To evaluate a `Definition`, we use the `eval` function. Consider the following example. The input data is a list of `Int` s if the list is empty (`null`), this is considered an error in `feat1`. If the list has more than 3 elements, then in `feat2`, the sum is computed; otherwise `0` is returned.

[source,haskell]
----
featInts :: [Int] -> Feature "someInts" [Int]
featInts = pure

feat1 :: Definition (Feature "someInts" [Int] -> Feature "hasMoreThan3" Bool)
feat1 = defineA
  (\ints -> if null ints then makeFeature (missingBecause $ Other "no data")
           else makeFeature $ featureDataR (length ints > 3))

feat2 :: Definition (
      Feature "hasMoreThan3" Bool
  -> Feature "someInts" [Int]
  -> Feature "sum" Int)
feat2 = define (\b ints -> if b then sum ints else 0)

ex0 = featInts []
ex0a = eval feat1 ex0 -- MkFeature (MkFeatureData (Left (Other "no data")))
ex0b = eval feat2 (ex0a, ex0) -- MkFeature (MkFeatureData (Left (Other "no data")))

ex1 = featInts [3, 8]
ex1a = eval feat1 ex1 -- MkFeature (MkFeatureData (Right False))
ex1b = eval feat2 (ex1a, ex1) -- MkFeature (MkFeatureData (Right 0))

ex2 = featInts [1..4]
ex2a = eval feat1 ex2 -- MkFeature (MkFeatureData (Right True))
ex2b = eval feat2 (ex2a, ex2) -- MkFeature (MkFeatureData (Right 10))
----

Note the value of `ex0b`. It is a `Left` because the value of `ex0a` is a `Left`; in other words, errors propogate along `Feature` s. If a given `Feature` 's dependency is a `Left` then that `Feature` will also be `Left`. A `Feature` 's internal `Either` structure has important implications for designing `Feature`s and performance. Capturing an error in a `Left` is a way to prevent downstream dependencies from even being computed.

==== Type Safety of Features

In describing the `Feature` type, the utility of having the name as a type may not have been clear. To clarify, consider the following example:

[source,haskell]
----
x :: Feature "someInt" Natural
x = pure 39

y :: Feature "age" Natural
y = pure 43

f :: Definition (Feature "age" Natural -> Feature "isOld" Bool)
f = define (>= 39)

fail = eval f x 
pass = eval f y
----	   

In the example, `fail` does not compile because "someInt" is not "age", even though both the data type are `Natural`.

=== Testing Features

=== Defining Cohort(s)

=== Testing Cohort(s)

=== Building the Application

=== Running the Application