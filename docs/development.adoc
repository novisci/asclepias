= Development

To develop and work with asclepias locally, clone the repository:

----
git clone git@gitlab.novisci.com:nsStat/asclepias.git
----

== Installing GHC and Cabal

To compile Haskell libraries and/or applications you will need a suitable Haskell compiler. Furthermore, to make the creation, distribution, and building of libraries and applications more convenient several systems and supporting tooling for defining Haskell packages have been created. In particular, the asclepias project uses the https://www.haskell.org/ghc/[Glasgow Haskell Compiler (GHC)] compiler and the https://www.haskell.org/cabal[Cabal] system for building and packaging Haskell libraries and programs so consequently it will be helpful to have GHC and Cabal available on your development platform.

=== Installing ghcup

To install GHC and Cabal we recommend using https://www.haskell.org/ghcup[ghcup], which is a utility that allows for easy downloading and installation of various applications in the Haskell toolchain. Please see the linked documentation for instructions on how to lauch the ghcup installer.

Once the installer is launched, you will be asked a series of questions. The following is a rough guide to the recommended answers for these questions.

* _Do you want ghcup to automatically add the required PATH variable to your shell startup file?_ This is optional. Either (i) you should choose the "Yes, prepend" option and the installer will add a line of code to the end of your shell startup file (e.g. `~/.bashrc`) appropriately modifying the `PATH` environmental variable, or (ii) you should choose the "No" option and manually add some code to your shell startup file performing an equivalent modification to `PATH`. In the latter case you should prepend `~/.cabal/bin` and `~/.ghcup/bin` to `PATH`.
* _Do you want to install haskell-language-server (HLS)?_ Select "Yes".
* _Do you want to install stack?_ There is no harm in selecting "Yes", but it is not necessary for the asclepias project. So in other words, you can select "No" and download it at a later time if desired.

Once installed use `ghcup --help` to see a description of all the available commands.

==== ghcup troubleshooting: SSL certificate problem

Some users on our team (as of January 2022) have reported difficulties when using ghcup (i.e. when using a command such as `ghcup list` after installation) where they encounter an error with a message like the following.
[literal]
curl: (60) SSL certificate problem: self signed certificate in certificate chain

Below we list a few workarounds that we have found for this issue.

* Update your OpenSSL certificates. If you installed OpenSSL on macOS through homebrew then you can use the command `brew postinstall openssl`.
* Upgrade the version of curl. If you run `curl --version` and it lists an old release date then you may want to install a newer version.
* Use wget instead of curl when running ghcup by specifying the option `--downloader=wget`. So for example, you can use the command `ghcup --downloader=wget list`

==== Obtaining the ghcup facilities information

Use the command `ghcup list` to orient yourself with the following information.

1. What applications and application versions are available for download through ghcup.
2. What applications have already been downloaded through ghcup.
3. What the current recommended version of an application is according to ghcup.
4. What version of a given application is active (see the <<ghcup application version management>> section for details on what is meant by "is active").

The first column of the table provided by `ghcup list` is the least obvious. If a given row has an "✗", then it means that the corresponding version of the application _hasn't_ been downloaded by ghcup. If it has a "✔", then it means that it _has_ been downloaded by ghcup, and if it has a "✔✔" then it means that it both _has_ been downloaded by ghcup _and is_ the currently active version.

==== ghcup application version management

The "active version" of a given application according to ghcup is the version that gets run when using a shell command such as `ghc` without supplying a version number (as in e.g. `ghc-9.2.1`). To change the currently active version for a particular application, use the `ghcup set` command. See `ghcup set --help` for details.

In more detail, ghcup stores various application versions in the `~/.ghcup/bin` directory which is assumed to be on your shell's path. Then for example, the `ghc` file located in that directory is a symbolic link to the active version of GHC according to ghcup (a similar pattern is used for other applications managed by ghcup). So suppose that the active version of GHC was GHC 8.10.7, then running the command `ghc` in your shell would run GHC 8.10.7 because the `~/.ghup/bin/ghc` file would a symbolic link pointing to GHC 8.10.7.

Note that if you wanted to run a different version of GHC, say GHC 9.2.1, for a particular project without changing the active version, then you could invoke that version directly by running the command `ghc-9.2.1` in your shell since this is one of the files in `~/.ghcup/bin` (assuming that it has previously been downloaded).

=== Installing GHC and Cabal using ghcup

To install an application you can use a command such as `ghcup install ghc 8.10.7`. Supplying the version number is optional, and if not supplied then ghcup will install what it considers to be the recommended version. To see which version of a given application that ghcup considers to be recommended, you can use `ghcup list` as described in the <<Obtaining the ghcup facilities information>> section. Use `ghcup install --help` for documentation.

We recommend installing the recommended version of Cabal according to ghcup, and the version of GHC used in the `.gitlab-ci.yml` file (see the `GHC` variable defined therein). So in summary, this means that you can run the following commands. Note that you may already have the necessary versions of GHC and Cabal installed in which case either or both of these commands can be omitted as appropriate (however there is no harm in running them in any case since ghcup is smart enough to not download an existing application a second time).
[source,shell]
----
ghcup install ghc 8.10.7  # double-check to ensure this is the correct version
ghcup install cabal
----

Note that if you already have a different version of GHC and/or Cabal installed through ghcup and you would like to change the active version then you can use the `ghcup set` command.

==== A note on the Cabal version

As you find your way around the asclepias project, you may notice that in the sub-project Cabal package description files (i.e. the files with filenames ending in `.cabal`), that the `cabal-version` is specified as an older version of Cabal (such as version 2.2) than can be downloaded through ghcup. According to https://cabal.readthedocs.io/en/3.6/cabal-package.html#pkg-field-cabal-version[the Cabal documentation] Cabal is mostly backwards compatible so there shouldn't be any issue with using a newer version.

==== A note on the GHC version and language extensions

As you find your way around the asclepias project, you may notice that in the sub-project Cabal package description files (i.e. the files with filenames ending in `.cabal`) that the `default-language` is specified as `Haskell2010`, which refers to the https://www.haskell.org/onlinereport/haskell2010/[Haskell 2010 language report], and is the current definition of the Haskell language (also see https://en.wikipedia.org/wiki/Haskell_(programming_language)#Haskell_2010[Wikipedia] and https://wiki.haskell.org/Language_and_library_specification#The_Haskell_2010_report[The Haskell Wiki]). GHC versions 8.0.2 and later implement the Haskell 2010 language report.

Although the Haskell language definition itself has stayed stable since the Haskell 2010 language report, the GHC compiler supports the adoption of new language features through the use of _language extensions_, which are opt-in non-standard language features. One of the effects of the specifying the Haskell 2010 language is that the language extensions listed in the https://downloads.haskell.org/~ghc/8.10.7/docs/html/users_guide/glasgow_exts.html#extension-Haskell2010[Haskell 2010 Language Extensions] in the GHC documentation are enabled by GHC.

Additional language extensions can be (and typically are) specified by various mechanisms in the sub-project Cabal package description files and/or in the source code files themselves as described in the https://kowainik.github.io/posts/extensions[Extensions] blog post.

== Compiling asclepias projects

=== asclepias project organization

The asclepias repository is organized using a multiple project setup. In more detail, some of the subdirectories of the repository such as `hasklepias-core`, `hasklepias-main`, etc. contain a Cabal package which we sometimes more generically call a "project" or "sub-project".

Note that in the following sections we often refer to a Haskell _module_, which for the time-being can be thought of as the contents of a Haskell file (but see the <<The Haskell module system>> section for a complete definition).

=== Cabal packaging overview

==== Cabal package definition

A Cabal package is defined by the following (see https://cabal.readthedocs.io/en/3.6/cabal-package.html#package-description[Package Description] in the Cabal documentation for full detail).

* A collection of Haskell files.
* A package description file with a name of the form `package-name.cabal` in the package root directory containing metadata about the package.
* In some circumstances, a file named `Setup.hs` in the package root directory containing instructions for various setup tasks. In more detail, this file is only needed when the `build-type` field in the package description file is specified as `Custom` (see https://cabal.readthedocs.io/en/3.6/cabal-package.html#pkg-field-build-type[The Package Field: build-type] in the Cabal documentation for more details).

So in general you can locate the various Cabal packages in the repository by using a command such as one of the ones shown below. For this particular project there is also a file `hie.yaml` (and which is described further in the <<A note on using HLS in multi-project repositories>> section) that should (unless it gets out-of-sync) accurately describe the package layout.
[source,shell]
----
# Using `find`
find . -path ./dist-newstyle -prune -o -name '*.cabal'

# Alternatively using `fd`
fd --exclude dist-newstyle '\.cabal$'
----

==== Cabal package description file format

The Cabal package description file (i.e. the `.cabal` file) contains information about the package such as the package name, version, structure, and dependencies. A good source of documentation for the format of this file can be found in https://cabal.readthedocs.io/en/3.6/cabal-package.html#package-descriptions[Package descriptions] in the Cabal documentation.

In short, the description file contains a number of top-level fields called _Package Properties_ and which contain information such as `cabal-version`, `name`, `version`, etc. In addition to these fields there may be an arbitrary number of sections from a fixed number of types that are called _Component Types_. The section type keywords include `library`, `executable`, and `test-suite` among others. Typically each section is named (with one important exception mentioned below) and contains a number of section-specific field/value pairs describing the given component. The fields within a section may optionally be indented, but each field within the section must have the same indentation.

Currently, there can only be one publicly exposed library in a package, and its name is the same as package name set by global name field. In this case, the name argument to the library section must be omitted (c.f. https://cabal.readthedocs.io/en/3.6/cabal-package.html#library[Library] in the Cabal documentation).

Some fields expect lists for their specified values which for a given field can rather confusingly take exactly one of three forms: space separated (no commas allowed between elements), comma separated (a comma is required between elements), or optional comma separated (the elements may all either be comma seperated or all not comma separated). Furthermore, all optional comma separated fields must follow the same comma or non-comma style (the non-comma style is recommended). The https://cabal.readthedocs.io/en/3.6/buildinfo-fields-reference.html[Field Syntax Reference] in the Cabal documentation lists the grammar for some of the fields.

==== Cabal package description file example

Consider the following abridged version of the `hasklepias-main.cabal` file. In this example we see the top-level fields (i.e. the package properties) `cabal-version`, `name`, and `version`, and following these fields we see a total of three sections. The first section has a "library" component type, and because its name is omitted (i.e. there is no text to the right of the `library` keyword) this is taken to be the sole publicly exposed library for the package, and is given the same name as is specified by the `name` field (i.e. `hasklepias-main`). The second section has a "test-suite" component type, and is given the name `examples`. The third section has an "executable" component type, and is given the name `exampleApp`.

The visibility of a given module in a package is controlled by the `other-modules`, `exposed-modules` and `main-is` fields. Note that every package module _must_ be listed in one of these fields.

* `exposed-modules`: a list of modules exposed to users of the package (note that this field is applicable only to libraries). Here "exposed" means that package users are able access the functions and data exported by a given exposed module.
* `other-modules:`: a list of modules used by the component but not exposed to users.
* `main-is`: the name of the file containing the `Main` module (note that this field is applicable only to executables).

The meaning of some of the other section-specific fields shown in the example is listed below.

* `default-language`: which definition of the Haskell language to use.
* `hs-source-dirs`: a list of the directories in which to search for Haskell modules.
* `build-depends`: a list declaring the library dependencies required to build the package component.
* `type`: has different meanings for various component types. For the `test-suite` type having a value of `exitcode-stdio-1.0` means that the testing interface is an executable that indicates test failure with a non-zero exit code when run.

[source,conf]
----
cabal-version:  2.2
name:           hasklepias-main
version:        0.22.5

library
  exposed-modules:
      Hasklepias
      Hasklepias.ExampleApp
      Hasklepias.ExampleFilterApp
  hs-source-dirs:
      src
  build-depends:
      edm
    , hasklepias-appBuilder
    , stype
    , hasklepias-core
    , hasklepias-templates
  default-language: Haskell2010

test-suite examples
  type: exitcode-stdio-1.0
  main-is: Main.hs
  other-modules:
      ExampleEvents
      ExampleFeatures1
      ExampleFeatures2
      ExampleFeatures3
      ExampleFeatures4
      ExampleCohort1
  hs-source-dirs:
      examples
  build-depends:
      hasklepias-main
    , hasklepias-core
    , hspec
    , base >=4.14 && <5
    , tasty  == 1.4.1
    , tasty-hunit == 0.10.0.3
    , tasty-hspec == 1.2
  default-language: Haskell2010

executable exampleApp
  main-is: Main.hs
  hs-source-dirs:
      exampleApp
  build-depends:
      hasklepias-main
  default-language: Haskell2010
----

=== Compiling asclepias packages

The `cabal build` command is used to compile Cabal packages and package components. There are many command-line arguments that can be provided with `cabal build`, however for the sake of brevity these are not covered here. See `cabal build --help` and https://cabal.readthedocs.io/en/3.6/cabal-commands.html#cabal-v2-build[cabal-build] in the Cabal documentation for full details.

==== Compiling all asclepias packages

As previously mentioned, the asclepias repository is organized using a multiple project setup. In more detail, some of the subdirectories of the repository such as `hasklepias-core`, `hasklepias-main`, etc. contain a Cabal package. The simplest thing to do to get started is to build (i.e. compile) all of the Cabal projects in the repository using the following command. Note that this could take around half-an-hour to complete the first time that you do it (future compilations take significantly less time since GHC will only recompile modules that have changed since the last compilation).
[source,shell]
----
cabal update
cabal build all
----

Note that by default Cabal doesn't compile the test suite or benchmarking modules when using `cabal build`. In the following sections we will see ways to compile these components if desired.

==== Compiling asclepias packages one-at-a-time

Alternatively, you can build the packages one-at-a-time using a command of the following form. This is useful when you are working on a particular project and don't want to compile everything at once in order to save time. Note that compiling a given package will still cause you to compile all of its dependencies, so the first time you compile a package can still take quite a long time if you have many dependencies to compile.
[source,shell]
----
cabal update
cabal build hasklepias-main
----

By default Cabal doesn't compile the test suite or benchmarking modules for a given package so if you want to compile the tests along with the package itself then you can use e.g. the `--enable-tests` and/or `--enable-profiling` options.
[source,shell]
----
cabal update
cabal build hasklepias-main --enable-tests --enable-profiling
----

==== Compiling asclepias package components

In addition to specifying a package name to compile, the `cabal build` command allows you to specify finer-grained units of compilation called _package components_, and where the package components correspond to the sections in the Cabal package description file. So for example, in the example <<Cabal package description file example>> section the package name was `hasklepias-main`, and the package components were called `hasklepias-main` (a library), `examples` (a test-suite), and `exampleApp` an executable (recall that the `hasklepias-main` library was implicitly named after the package name).

Typically package components are identified using the form `package:component` (the available syntax is actually more flexible than the form shown here). So for example, you could use the command `hasklepias-main:examples` to compile the `examples` component from the `hasklepias-main` package.

Additionally you can use one of the forms `package:ctype` or `all:ctype` to compile all components of the specified type (i.e. the `ctype`) for a given package or across all packages, respectively. So for example, you could use the command `hasklepias-main:executables` to compile any components with a library component type from the `hasklepias-main` package (of which there happens to be one component, i.e. the `exampleApp` component), or the command `all:executables` to compile any components with a library component type from any package the asclepias repository.

There are other ways of specifying a component by specifying either a module name or the filepath of a module that belongs to the target component, however we do not cover those approaches here.
[source,shell]
----
cabal update

# Using the `package:component` form
cabal build hasklepias-main:hasklepias-main
cabal build hasklepias-main:examples
cabal build hasklepias-main:exampleApp

# Using the `package:ctype` form
cabal build hasklepias-main:libraries
cabal build hasklepias-main:tests
cabal build hasklepias-main:executables

# Using the `all:ctype` form
cabal build all:libraries
cabal build all:tests
cabal build all:executables
----

== Setting up a development environment

=== Installing an editor

Haskell development is well-supported by many popular editors such as https://code.visualstudio.com[Visual Studio Code], https://www.sublimetext.com/[Sublime Text], https://www.vim.org/[vim] / https://neovim.io/[Neovim], https://atom.io/[Atom], https://www.gnu.org/software/emacs/[Emacs], and others. If you do not have a preexisting preference of editor then we recommend using Visual Studio Code to get started since it is easy to set up for Haskell development and is currently the most popular editor overall.

To see installation instructions for a given editor listed above, please visit the corresponding provided link. Note however that in the case of Emacs it is fairly common to use an Emacs distribution (basically a collection of packages bundled with base Emacs) to reduce the effort required to set up Emacs such as https://www.spacemacs.org/[Spacemacs], https://github.com/hlissner/doom-emacs[Doom Emacs], https://prelude.emacsredux.com/en/latest/[Emacs Prelude], or https://github.com/purcell/emacs.d[Purcell Emacs], among many others.

=== Installing the Haskell Language Server

The https://github.com/haskell/haskell-language-server[Haskell language server] (HLS) implements the https://microsoft.github.io/language-server-protocol/[Language Server Protocol] (LSP) for the Haskell language. It can be very useful for development when paired with an editor with support for LSP (such as one of the editors mentioned above) since it provides immediate feedback from the compiler, among other features.

You can use ghcup to install whatever its current recommended version of HLS is. Note that you may already have installed HLS during the ghcup installation process or at some other time, in which case you can skip this step (however there is no harm in running it in any case since ghcup is smart enough to not download an existing application a second time).
[source,shell]
----
ghcup install hls
----

=== Configuring your editor to utilize HLS

Please see  https://haskell-language-server.readthedocs.io/en/latest/configuration.html#configuring-your-editor[Configuring your editor] in the HLS documentation for instructions on how to configure your editor to utilize HLS.

==== A note on using HLS in multi-project repositories

Since the asclepias repository has a multiple project layout (i.e. hasklepias-core, hasklepias-main, etc.), it may not be obvious how to set up HLS. For example, should you run one server that serves all of the files across the various projects, or should you run one server per project?

To resolve this issue, the asclepias repository provides a file `hie.yaml` in the repository root that specifies the HLS configuration for all of the projects in the repository (see the https://github.com/haskell/hie-bios[hie-bios documentation] for details). As a result of this setup, you can run a single HLS server that will work correctly for all of the projects in the repository. If you are asked by your editor to specify what directory to start HLS in then you can use the repository root directory.

Note that some editors may automatically detect the hie-bios configuration setup in the repository and just "do the right thing." If you open a Haskell file in your editor and LSP seems to be working properly then you are probably good-to-go.

==== Troubleshooting HLS

If HLS ever stops working, you may need to clear the cache:

[source,shell]
----
rm -rf ~/.cache/hie-bios/dist-asclepias*
----

== The Haskell module system

Gaining familiarity with the Haskell module system is helpful in becoming proficient with the asclepias Haskell libraries. Furthermore, to fully understand how the provided mechanisms work we will need a basic understanding of Haskell modules and how they are used to manage namespacing. The following subsections provide a basic description of the Haskell module system, but for a complete description please see the following documentation.

* https://www.haskell.org/tutorial/modules.html[Modules] in A Gentle Introduction to Haskell.
* https://www.haskell.org/onlinereport/haskell2010/haskellch5.html[Modules] in the Haskell 2010 Language Report.

=== Haskell module overview

A Haskell program consists of a collection of modules. The primary purpose of modules is to provide a mechanism for namespacing. A module is defined as a Haskell declaration and is given a name. By convention, exactly one module is included per file with the filename sans suffix exactly matching the module name. So for example, if a module was named `Features`, then it would be the sole module included in the file `Features.hs`.

Module names are required to be a sequence of one or more strings beginning with capital letters and separated by dots with no intervening spaces, such as e.g. `Features` or `Cohort.Core`. The `.` separator is provided to allow package authors to indicate a hierarchy, however the language itself considers all modules to belong to a flat namespace (in other words the `.` separators have no effect on the program). By convention, a module named `Cohort.Core` would be the sole module declared in the file `Cohort/Core.hs`.

=== Haskell module declarations

The standard form of a module declaration is defined by the keyword `module` followed by the module name, followed by an optional list of entities enclosed in round parentheses to be exported, followed by the `where` keyword, and followed by the module body (there is also an abbreviated form of the module declaration provided for one special case that is not mentioned here). The body consists of 0 or more import declarations, followed by 0 or more top-level declarations. So in the following example the module is named `ExampleCohort1`, the export list has the single entity `exampleCohort1tests`, and the body consists of two import declarations followed by two top-level declarations.

[source,haskell]
----
-- Module header
module ExampleCohort1
  ( exampleCohort1tests
  ) where

-- Import declarations
import Cohort.Attrition
import Hasklepias

-- Top level declarations
lookback455 :: Integer
lookback455 = 455
----

=== Haskell module exports

Each Haskell module can export 0 or more declarations. Declarations include things like data and type declarations, class and instance declarations, type signatures, function definitions, and so on.

Since this section requires some prior knowledge of Haskell to fully understand it we have included two subsections, one which can be read during a first pass, and another which can be read at a later time if desired.

==== Haskell module exports: first approximation

Suppose the export list looks like the following. Loosely speaking this means the following.

1. The `Status` entity is exported. The `(..)` syntax can be thought of as meaning "all of the components of the entity."
2. The `makeBaselineFromIndex` entity is exported. Many types of entities are just a singular thing and thus the `(..)` syntax is not applicable.
3. The `Cohort.Attrition` module is reexported (this implies that `Cohort.Attrition` is imported somewhere in the module body).

[source,haskell]
----
  ( Status(..)
  , makeBaselineFromIndex
  , module Cohort.Attrition
  )
----

==== Haskell module exports: in more detail

The full export specification is rather involved so we will not try to cover everything in full detail, but rather try to cover the most common cases. See https://www.haskell.org/onlinereport/haskell2010/haskellch5.html#x11-1000005.2[Export Lists] in the Haskell 2010 Language Report for complete documentation.

* Data types declared using a `data` or `newtype` declaration are typically exported by one of the following forms. Suppose we have the declaration `data Status = Include | Exclude`. Then
** The statement `Status(..)` exports the `Status` data type as well as all of its constructors, which in this case are `Include` and `Exclude`.
** The statement `Status` exports the `Status` data type but not its constructors (which makes the data type an `abstract data type`, i.e. you can't construct one "by hand").
* Data types declared using a `type` declaration are exported using the type name.
* Values are exported by providing the value name.
* Classes are typically exported by using the following form. Suppose that we have a declared a class `Predicatable` with methods `(|||)` and `&&&`. Then the form `Predicatable(..)` exports the `Predicatable` class as well as all of its methods, which in this case are `(|||)` and `(&&&)`. It is also possible to export `Predictable` without exporting all of its method declarations, but this is usually not very useful.
* Imported modules can be reexported by using the following form. Suppose that we import the module `Cohort.Attrition`, then we can reexport the module using the statement `Module Cohort.Attrition`.

=== Haskell module imports

Understanding how Haskell module imports function can be helpful in gaining facility with asclepias since it enables you to trace back where various entities are defined or created. At a high level, an import serves to add 0 or more entities to the module top-level scope. A full definition of module imports can be found in https://www.haskell.org/onlinereport/haskell2010/haskellch5.html#x11-1010005.3[Import Declarations] in the GHC documentation.

One concept that module imports provide is that of _qualified_ and _non-qualified_ imports (non-qualified imports are usually referred to simply as "imports"). Suppose that we were to specify a qualified import of the `ExampleEvents` module (see Example 1 below). This would mean that a given entity exported from within `ExampleEvents` has to be referred to via the `ExampleEvents` namespace. So suppose that `ExampleEvents` exports an entity `exampleEvents1`, then the default syntax to refer to this entity would be `ExampleEvents.exampleEvents1`. There is also a way to specify an alternative name for the namespace such as `EE` instead of ExampleEvents to make it more convenient to use within the module (see Example 2 below). On the other hand, a non-qualified import would simply place all of the exported entities from ExampleEvents into the top-level scope (see Example 3 below). So in that case you can just refer to `exampleEvents1` directly.

The module import system also allows you to import a subset of the exported entities from a given module. To do this you can either provide a list of entities to include from the module exports (see Example 4 below), or conversely you can provide a list of entities to remove from the module exports (see Example 5 below).

Some examples of various forms of module imports are shown below. Note that each of these examples would be expected to come from different module declarations.
[source,haskell]
----
-- Example 1. All exported entities from `ExampleEvents` are available in the
-- module, but must be referred to through the `ExampleEvents` namespace
import qualified ExampleEvents
----
[source,haskell]
----
-- Example 2. All exported entities from `ExampleEvents` are available in the
-- module, but must be referred to through the `EE` namespace
import qualified ExampleEvents as EE
----
[source,haskell]
----
-- Example 3. Add all exported entities from `ExampleEvents` to the top-level
-- scope
import ExampleEvents
----
[source,haskell]
----
-- Example 4. Add only `exampleEvents1` and `exampleEvents2` to the top-level
-- scope
import ExampleEvents (exampleEvents1, exampleEvents2)
----
[source,haskell]
----
-- Example 5. Add everything but `exampleSubject1` and `exampleSubject2` to the
-- top-level scope
import ExampleEvents hiding (exampleSubject1, exampleSubject2)
----

== Interactive usage of GHC

The GHC compiler provides an interactive environment (i.e. a read–eval–print loop or REPL) called GHCi (the "i" stands for "Interactive"). It can be very helpful to experiment with the REPL while writing Haskell code, much as you would with other programming languages like R or Python. See https://downloads.haskell.org/~ghc/8.10.7/docs/html/users_guide/ghci.html[Using GHCi] in the Cabal documentation for the full GHCi documentation.

=== Starting GHCi in Cabal projects

To run GHCi in a Cabal project you can use the `cabal repl` command followed by an optional target package component (by default `cabal repl` loads the first component in a package). There are many command-line arguments that can be provided with `cabal repl`, however for the sake of brevity these are not covered here. See `cabal repl --help` and https://cabal.readthedocs.io/en/3.6/cabal-commands.html#cabal-v2-repl[cabal repl] in the Cabal documentation for full details.

The `cabal repl` command uses the same method of specifying a target package component as for `cabal build` (see the <<Compiling asclepias packages>> section for details). So for example, the following command will start GHCi and load the modules in the `examples` component of the `hasklepias-main` package into the session (see the <<Loading modules into GHCi>> section for more detail on what "load" means).
[source,shell]
----
cabal repl hasklepias-main:examples
----

=== Loading modules into GHCi

Loosely speaking, loading a module means that the declarations in the module are made known to GHCi. Loading a module is a prerequisite to adding the module data and definitions to the GHCi top-level scope (unless the module is part of a package known to GHCi). To see what modules are loaded in a GHCi session at any given time you can use the command `:show modules` in the REPL.

When GHCi is invoked through `cabal repl` all of the modules in the specified package component are loaded into GHCi. So for example, if GHCi is invoked using the command `cabal repl hasklepias-main:examples`, then the modules in the `examples` component of the `hasklepias-main` package are loaded into the session. Additionally, if you want to change which modules are loaded during your session then you can use the `:load` command in the REPL to (i) load 0 or more specified modules and (ii) to forget all of the previously loaded modules. We note however, that it is often more convenient to simply close the current GHCi session and start a new session with a new package component loaded.

The following examples demonstrate how to view and change what modules are currently loaded.
[source,shell]
----
cabal repl hasklepias-main:examples
----
[source]
----
:show modules

:load ExampleCohort1
:show modules

:load ExampleCohort1 ExampleEvents
:show modules
----

For more details see the following documentation.

* https://cabal.readthedocs.io/en/3.6/cabal-package.html#opening-an-interpreter-session
* https://downloads.haskell.org/~ghc/8.10.7/docs/html/users_guide/ghci.html#loading-source-files
* https://downloads.haskell.org/~ghc/8.10.7/docs/html/users_guide/ghci.html#ghci-cmd-:load
* https://downloads.haskell.org/~ghc/8.10.7/docs/html/users_guide/ghci.html#module-and-load

=== Reloading updated modules in GHCi

When you update the source code for a given module or modules that have already been loaded and you want GHCi to recompile the program, you can use the `:reload` command.

=== Managing scope in GHCi

GHCi provides support for fine-grained control over what top-level declarations are available in the session (i.e. what is in scope). The following subsections describe that various mechanisms that can used to modify the scope. See https://downloads.haskell.org/~ghc/9.0.1/docs/html/users_guide/ghci.html#what-s-really-in-scope-at-the-prompt[What’s really in scope at the prompt?] for full details.

==== Module import *-form in GHCi

When a given module is imported in GHCi (i.e. added to the current scope) it can be in one of two forms: the usual import form and a so-called *-form. The regular form places the module exports in scope, whereas the *-form places all top-level bindings in the module in scope.

==== Viewing the current scope in GHCi

Use the command `:show imports` to list the modules that are currently in scope, and the command `:show bindings` to list any binding that were declared directly in the REPL.

Suppose that the output of `:show imports` looks like the following. This can be read as meaning that the exports from the `ExampleEvents` and `ExampleFeatures1` modules are in scope, whereas the entirety of the `ExampleCohort1` and the `Main` modules are in scope (i.e. they are *-form imports).
[source]
----
:module +*ExampleCohort1
import ExampleEvents
import ExampleFeatures1
:module +*Main -- added automatically
----

==== How module loads affect scope in GHCi

When modules are loaded at GHCi startup (e.g. after invoking `cabal repl`) or through the `:load` command then a secondary effect of the load is that an automatic import is added to the scope for the most recently loaded target module. The effect of this import is that (i) the data and definitions of the module are made available to the top-level scope in GHCi, and (ii) all other bindings are removed from the top-level scope.

==== Controlling what is in scope with `import`

You can use the full Haskell `import` syntax to add a module's exports (or possibly a subset of them) to the scope. In the following example we add the exports from `ExampleFeatures1` and `ExampleFeatures1` to the scope. See https://downloads.haskell.org/~ghc/9.0.1/docs/html/users_guide/ghci.html#controlling-what-is-in-scope-with-import[Controlling what is in scope with import] in the GHC documentation for full details.
[source,shell]
----
cabal repl hasklepias-main:examples
----
[source]
----
:show imports

:import ExampleFeatures1
:show imports

:import ExampleEvents
:show imports
----

==== Controlling what is in scope with the `:module` command in GHCi

An alternative to using an `import` command to modify the scope is to use the `:module` command. In the following example we see three forms of the `:module` command: one with a `+` that adds module declarations to the current scope, one with a `-` that removes module declarations from the current scope, and one without either a `+` or a `-` that replaces the current scope with a new scope. Furthermore, each module that is imported by the `:module` command can be either a regular import or a *-form input. See https://downloads.haskell.org/~ghc/9.0.1/docs/html/users_guide/ghci.html#controlling-what-is-in-scope-with-the-module-command[Controlling what is in scope with the :module command] in the GHC documentation for full details.
[source,shell]
----
cabal repl hasklepias-main:examples
----
[source]
----
:show imports

:module + *ExampleCohort1 *ExampleEvents ExampleFeatures1 ExampleFeatures2
:show imports

:module - ExampleEvents ExampleFeatures2
:show imports

:module *ExampleCohort1 *ExampleEvents
:show imports
----

== Linting and Formatting

The CI process checks that code in the repository is appropriately formatted and linted, using the https://hackage.haskell.org/package/brittany[`brittany`] and  https://github.com/ndmitchell/hlint[`hlint`] tools respectively. 

You can install these locally using (e.g.) `cabal`:

[source,shell]
----
cabal install brittany
cabal install hlint
----

Scripts are provided to format code locally with:

[source,shell]
----
./scripts/format.sh
----

or linted using: 

[source,shell]
----
./scripts/lint.sh
----

