---
title: "Project Asclepias"
subtitle: "A Functional Approach to Cohort Construction"
author: "Bradley Saul"
date: "4/8/2019"
output: html_document
editor_options: 
  chunk_output_type: console
---
```{r, echo = FALSE, message=FALSE}
library(ggplot2)
library(dplyr)
```




# Background

* cohort package
* Why a functional approach? What is it?
* The business case

# Design

## Data Structures

The fundamental data structure in this approach is that of events occurring in time with information attached to the event such as a hospital stay, disease diagnosis, or lab values. We most often work on the time scale of days, so we'll think about the time intervals in terms of integers.

Define an event $w$ as a set with an interval and a context:

\[
w := \{\Theta, \square\}
\]

\[
w := \{\Xi, \square\}
\]


### Interval

An interval $\iota$ is as an ordered pair defining the start and end of a segment on the integer line.

\[
\iota := (a, b) \mid a \leq b \in \mathbb{Z}
\]

Let $\mathcal{I}$ be the set of all $\Xi$. Here's a few $\iota$s represented visually:

```{r, echo = FALSE, fig.height = 1}
num_line_baseplot <- function(a, b){
  ggplot() + 
    geom_blank() + 
    scale_x_continuous(
      limits = c(a - 1, b + 1),
      expand = c(0, 0),
      breaks = function(l) seq(l[1] + 1, l[2] - 1, by = 1)
    ) + 
    theme_minimal() + 
    theme(
      panel.grid  = element_blank(), 
      axis.line.x = element_line(size = 0.5, color = "black", 
                                 arrow = arrow(ends = "both", 
                                               length = unit(0.2, "npc"))),
      axis.ticks.x = element_line(size = 0.25),
      axis.title   = element_blank(),
      axis.text.y  = element_blank()
    )
}

dt <- tibble::tibble(
  a = c(-1, -1, 2, 5),
  b = c(0, 3, 10, 5),
  y = c("0", "1", "2", "3")
)

num_line_baseplot(-2, 10) + 
  geom_segment(
    data = dt,
    aes(x = a, xend = b, y = y, yend = y),
    lineend = "round"
  ) + 
  geom_point(
    data = dt,
    aes(x = b, y = y), color = "red"
  ) +
  geom_point(
    data = dt,
    aes(x = a, y = y), color = "blue"
  ) 
```

To make the math concrete, define data structures in a programming language (in this case `R`) that align with our mathematical definition.

```{r, echo = FALSE, message=FALSE, results = "hide"}
interval <- setClass("interval", slots = c(a = "integer", b = "integer"))

setMethod("as.character", "interval", function(x) {
   sprintf("(%s, %s)", slot(x, "a"), slot(x, "b"))
})

setMethod("show", "interval", function(object) {
   cat(as.character(object))
})
interval_pair <- setClass("interval_pair", slots = c(a = "interval", b = "interval"))

interval_pair_o <- setClass(
  "interval_pair_o", 
  contains = "interval_pair",
  validity = function(object){
    ordered(slot(object, "a"), slot(object, "b"))
  })

setMethod("show", "interval_pair", function(object) {
   cat(sprintf("(%s, %s)", as.character(slot(object, "a")), as.character(slot(object, "b"))))
})

setMethod("show", "interval_pair_o", function(object) {
   cat(sprintf("<%s, %s>", as.character(slot(object, "a")), as.character(slot(object, "b"))))
})
setGeneric("s", function(object) standardGeneric("s") )
setMethod("s", "interval", function(object) slot(object, "a"))
setGeneric("e", function(object) standardGeneric("e") )
setMethod("e", "interval", function(object) slot(object, "b"))
setGeneric("ennummerate", function(object) standardGeneric("ennummerate") )
setMethod("ennummerate", "interval", function(object) s(object):e(object))
setMethod("length", "interval", function(x) e(x) - s(x))
setGeneric("flipl", function(object, ...) standardGeneric("flipl") )
setMethod("flipl", "interval", 
          function(object) interval(a = s(object) - length(object), b = s(object)))
setGeneric("flipr", function(object, ...) standardGeneric("flipr") )
setMethod("flipr", "interval", 
          function(object) interval(a = e(object), b = e(object) + length(object)))
setGeneric("shift", function(object, ...) standardGeneric("shift") )
setMethod("shift", "interval", function(object, c) interval(a = s(object) + c, b = e(object) + c))
setGeneric("expandl", function(object, ...) standardGeneric("expandl") )
setMethod("expandl", "interval", function(object, c) interval(a = s(object) - c, b = e(object)))
setGeneric("expandr", function(object, ...) standardGeneric("expandr") )
setMethod("expandr", "interval", function(object, c) interval(a = s(object), b = e(object) + c))
setGeneric("expand", function(object, ...) standardGeneric("expand") )
setMethod("expand", "interval", function(object, c)  expandr(expandl(object, c), c))
# setGeneric("expand", function(object, ...) standardGeneric("expand") )
setGeneric("ordered", function(x, y) standardGeneric("ordered") )
setMethod("ordered", c("interval", "interval"), 
          function(x, y) { s(x) <= s(y)  })
setGeneric("order", function(x) standardGeneric("order") )
setMethod(
  "order", 
  "interval_pair",
  function(x) {
    if(ordered(slot(x, "a"), slot(x, "b"))) {
      interval_pair_o(a = slot(x, "a"), b = slot(x, "b"))  
    } else {
     interval_pair_o(a = slot(x, "b"), b = slot(x, "a"))  
    }
})
setGeneric("overlaps", function(x) standardGeneric("overlaps") )
setMethod(
  "overlaps", 
  "interval_pair_o", 
  function(x) { 
    s(slot(x, "b")) <= e(slot(x, "a")) 
  })
```

```{r}
itv <- interval(a = 2L, b = 4L)
itv
```

We're going to get into functions later, but a few basic functions might help contextualize what we can do with the interval data structure.
 
| Definition     | Mapping                      | Description        |
| ------------   | ---------------------------- | ------------------ |
| $s(\iota) = a$ | $s : \mathcal{I} \mapsto \mathbb{Z}$ | Gets the interval's start | 
| $e(\iota) = b$ | $e : \mathcal{I} \mapsto \mathbb{Z}$ | Gets the interval's end   |
| $shift(\iota, c) = (s(\iota) + c, e(\iota) + c)$ | $shift : (\mathcal{I}, \mathbb{Z}) \mapsto \mathcal{I}$ | Shifts an interval by $c$ |
| $expandl(\iota, c) = (s(\iota) - c, e(\iota))$ | $expandl : (\mathcal{I}, \mathbb{Z}) \mapsto \mathcal{I}$ | Expands an interval to the left by $c$ | 
| $expandr(\iota, c) = (s(\iota), e(\iota) + c)$ | $expandr : (\mathcal{I}, \mathbb{Z}) \mapsto \mathcal{I}$ | Expands an interval to the right by $c$ | 
| $expand(\iota, c) = (s(\iota) - c, e(\iota) + c)$ | $expand : (\mathcal{I}, \mathbb{Z}) \mapsto \mathcal{I}$ | Expands an interval by $c$ | 
| $length(\iota) = e(\iota) - s(\iota)$ | $length : \mathcal{I} \mapsto \mathbb{Z}$ | Measures the length of an interval | 
| $flipl(\iota)  = (s(\iota) - length(\iota), s(\iota))$| $flipl : \mathcal{I} \mapsto \mathbb{Z}$ | Flips an interval to the left | 
| $flipr(\iota)  = (e(\iota), e(iota) + length(\iota))$| $flipr : \mathcal{I} \mapsto \mathbb{Z}$ | Flips an interval to the right | 
| $ennummerate(\iota) = \{z \mid z \in \mathbb{Z}, z >= s(\iota), z <= e(\iota)\}$ | $ennummerate : \mathcal{I} \mapsto \mathbb{Z}$ | Ennumerates all the integers in an interval | 
| $ordered(\iota, \iota') = \begin{cases} TRUE  & s(\iota) \leq s(\iota') \\ FALSE & else\end{cases}$ | $ordered : (\mathcal{I}, \mathcal{I}) \mapsto \mathbb{B}$ | determines if two intervals are ordered such that $s(\iota) \leq s(\iota')$ | 
| $order( ( \iota, \iota' ) ) = \begin{cases} <\iota, \iota'>  & ordered(\iota, \iota') = TRUE \\ < \iota', \iota > & ordered(\iota, \iota') = FALSE \end{cases}$ | $order : (\mathcal{I} \times \mathcal{I}) \mapsto \mathcal{I^{2}_o}$ where $\mathcal{I}^{2}_o = \{ < \iota, \iota' >\}$ and $<\cdot, \cdot>$ indicates that the pair of elements are ordered | puts two intervals into order s.t. $s(\iota) \leq s(\iota')$ | 
| $overlaps( <\iota, \iota'> ) = \begin{cases} TRUE  & s(\iota') \leq e(\iota) \\ FALSE & else\end{cases}$ | $overlaps : \mathcal{I^{2}_o} \mapsto \mathbb{B}$  | determines if two ordered intervals overlap | 

These functions may seem trivial, but they reveal a few concepts:

* We've expressly defined the data types of function's input and output.
* Starting with simple accessor functions ($s$ and $e$) and basic set, relational, and arithmetic operators, we created simple functions that form the building blocks for more complicated functions. 

Here are the functions in action:

```{r, error = TRUE}
itv <- interval(a = 2L, b = 10L)
s(itv)
e(itv)
ennummerate(itv)
length(itv)
flipl(itv)
flipr(itv)
shift(itv, 5L)
expandl(itv, 5L)
expandr(itv, 5L)
expand(itv, 5L)
ordered(itv, interval(a = 5L, b = 11L))

interval_pair(a = itv, b = interval(a = -1L, b = 10L)) %>%
  order() %>%
  overlaps()

interval_pair(a = itv, b = interval(a = -1L, b = 0L)) %>%
  order() %>%
  overlaps()
```

### Context

Define a context $\square$ as an arbitrary, finite collection of objects. A context is always paired with a $\iota$ as an event (defined below) and contains all the relevant information about the $\iota$ such as a type and associated values.

For the purposes of this demonstration, let the context be the pair the suit and value of a poker card:

\[
\square \in \{suit \in \mathcal{S} = \{\clubsuit, \heartsuit, \diamondsuit, \spadesuit \}, value \in \mathcal{V} = \{A, 2, 3, 4, 5, 6, 7 , 8, 9, 10, J, Q, K\}\}
\]

Let $\overline{\square}$ be the set of all contexts specific to our study.

Define a couple of accessor functions for our specific context:

| Definition      | Mapping                      | Description        |
| ------------    | ---------------------------- | ------------------ |
| $suit(\square)$ | $suit : \overline{\square}\ \mapsto \mathcal{S}$ | Gets the suit of a context. |
| $value(\square)$ | $value : \overline{\square}\ \mapsto \mathcal{V}$ | Gets the value of a context |

```{r echo = FALSE, message= FALSE, results = "hide"}
suit  <- setClass(
  "suit", contains = "character", 
   validity = function(object) { object %in% c("spade", "heart", "club", "diamond")})

setMethod(
  "print", "suit",
  function(x){
    switch(x,
      "spade"   = "\U2660",
      "club"    = "\U2663",
      "heart"   = "\U2665",
      "diamond" = "\U2666"
    )
  }
)

setMethod("show", "suit", function(object) cat(print(object)))
setGeneric("suit", function(x){standardGeneric("suit")})
setMethod("suit", "character", function(x) new("suit", x))
setGeneric("value", function(x){standardGeneric("value")})
context <- setClass("context", slots = c(suit = "suit", value = "character"))
setMethod("as.character", "context", function(x) {
   sprintf("{%s, %s}", print(slot(x, "suit")), slot(x, "value"))
})
setMethod("show", "context", function(object) {
   cat(as.character(object))
})

setMethod("suit", "context", function(x) x@suit)
setMethod("value", "context", function(x) x@value)
```

```{r}
c1 <- context(suit = suit("heart"), value = "3")
c2 <- context(suit = suit("diamond"), value = "J")

suit(c1)
suit(c2)
value(c1)
value(c2)
```

### Event


Events are collected into an indexed, partially ordered set:

\[
W = \{ (w_1, w_2, \dots, w_n) \mid  a_i \leq a_{i + 1} \; i = 1, \dots, n, b_i \leq b_{i + 1} \: \forall a_i = a_{i + 1} \}
\]

```{r, echo = FALSE, message = FALSE, results = "hide"}
event <- setClass("event", slots = c("interval" = "interval", "context" = "context"))
setMethod("as.character", "event", function(x){
  sprintf("{%s, %s}",  as.character(slot(x, "interval")), as.character(slot(x, "context")))
})
setMethod("show", "event", function(object) { cat(as.character(object)) })
setGeneric("as.event", function(x) standardGeneric("as.event"))
setMethod("as.event", "list", function(x) new("event", interval = x[[1]], context = x[[2]]))
```

```{r}
event(interval = itv, context = c1)
event(interval = interval(a = 4L, b = 20L), context = c2)
```

Here's a randomly generated set $W$.

```{r, echo = FALSE}
set.seed(12)
n <- 20
W <- tibble::tibble(
  x     = sample(1L:100L, size = n, replace = TRUE),
  y     = x + sample(0L:10L, size = n, replace = TRUE, prob = c(.5, rep(.05, 10))),
  suit  = sample(c("heart", "club", "spade", "diamond"), size = n, replace = TRUE),
  value = sample(c("A", "2", "3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K"),
                 size = n, replace = TRUE)
) 

Wdt <- W %>%
  mutate(interval = purrr::map2(x, y, ~ interval(a = .x, b = .y)),
         context  = purrr::map2(suit, value, ~ context(suit = suit(.x), value = .y))) %>%
  dplyr::arrange(x, y)

W <- apply(select(Wdt, interval, context), 1, as.event)
cat(paste0(Map(function(x) as.character(x), W), collapse = ",\n"))
```

And here's $W$ represented graphically where y-axis is used to differentiate each $w$ by its suit:

```{r, echo = FALSE, fig.height=3}
ggplot(
  data = select(Wdt, x, y, suit, value),
  aes(x = x, y = suit)
) + 
  geom_segment(
    aes(xend = y, yend = suit),
    color = "grey90", size = 0.5) +
  geom_point(
    aes(shape = suit),
    size = 5, position = position_dodge(width = 0.8) ) + 
  geom_text(
    aes(x = x, y = suit, label = value),
    size = 5, nudge_y = 0.3) + 
  scale_shape_manual(
    guide  = FALSE,
    values = c("spade"= "\u2660", "heart" = "\u2665", 
               "club" = "\u2663", "diamond" = "\u2666")
  ) +
  # scale_y_discrete(expand = c(0, 0)) + 
  theme_classic() +
  theme(
    axis.line.x = element_line(size = 0.5, color  = "black"),
    axis.ticks.x = element_line(size = 0.5),
    axis.title   = element_blank(),
    axis.text.y  = element_blank()
  )
```

### Specification

TODO: a specification is a data type that specifies the composition and ordering of functions that define features.

\newpage

## Functions


### Accessors

As described above, accessor functions extract information from an event $w$. For example:

\[
\mathsf{a}_{\iota}(w) = (a, b); \mathsf{a}_s(w) = (s \circ \mathsf{a}_{\iota}) (w) = a ; \mathsf{a}_{\square}(w) = \square
\]


Functions can also be defined that operate on collections of events, for example:

\[
\mathsf{a}_s(W) = \{(a_1, \dots, a_n) | a_i = \mathsf{a}_s(w_i) \,\, \forall w_i \in W\}
\]

## Predicates

A predicate $\mathsf{P}$ is a function that returns a boolean (or $\{0, 1\}$) based on $w$ that is constructed by an accessor and a relational operator.

\[
\mathsf{P}^c : (\mathsf{a}, \cdot) \mapsto \mathsf{P}: w \mapsto  \{0, 1\}
\]

where $a$ is an accessor function and $\cdot$ is a relational operator. Defined similarly for a set of events:

\[
\mathsf{P}^c : (\mathsf{a}, \cdot) \mapsto \mathsf{P}: W \mapsto \{\{0, 1\}^n\}
\]

Predicates are constructed from acessors and relations. For example, the following function returns $1$ when the start of $w$ is less than or equal to some constant $c$:

\[
\mathsf{P}'(w) = \begin{cases}
1 & \mathsf{a}_s(w) \leq c \\
0 & else
\end{cases}
\]

where $\mathsf{P}' = \mathsf{P}^c(\mathsf{a}_s, < c)$.

## Filter

A filter is a function $\mathsf{L}$ that subsets $W$ based on a set of predicate functions $\{\mathsf{P}\}$.

\[
\mathsf{L}: (\mathsf{P}, W) \mapsto W';  W' \subseteq W
\]


Here's an example filter function that filters $W$ based on $\mathsf{P}'$:

\[
\mathsf{L}'(\mathsf{P}, W) = \{w \in W | \mathsf{P}'(w) = 1 \}
\]

Implemented in `R` it might look something like this.

```{r}
a_i <- function(w) w@interval
a_s <- function(w) s(a_i(w))
P1  <- function(w) a_s(w) > 50
L1  <- function(w) Filter(P1, w)
L1(W)
```

But we can think even higher level and produce function molds. Here's an example.

```{r}
a_cast <- function(name1, name2){
  function(w){
    slot(w, name1) %>% slot(name2)
  }
}

a_cast("interval", "a")(W[[1]])
a_cast("context", "value")(W[[1]])

p_cast <- function(accessor, relation, bound){
  force(accessor);
  function(w){
    relation(accessor(w), bound)
  }
}

l_cast <- function(p){
  force(p)
  function(w){
    Filter(p, w)
  }
}
```

Which can then be composed to extract elements from $W$.

```{r}
a_cast("interval", "a") %>%
  p_cast(`<=`, 10) %>%
  l_cast() %>%
  {.(W)}
```


## Features

A feature is a function that extracts data $D$ from a set $W$. Features are composed from the types of functions described above: accessors, predicates, and filters (and map/reduce functions).

\[
\mathsf{F}: W \mapsto D
\]

For example, let's define the "start of the first $\heartsuit$ after the start of the first $\spadesuit$". As a function of $W$, this can be expressed as

\[
\mathsf{F}^{\star}(W) = \min \{ \mathsf{a}_s(z) | z \in W' = \mathsf{L}^{\star}(W) \}
\]

where $\mathsf{L}^{\star}$ filters $W$ to the set of all $w$ that occur after the first $w$ with $\spadesuit$:

\[
\mathsf{L}^{\star}(W) = \{w | \mathsf{a}_s(c)  > \min(\mathsf{a}_s(s)), s \in S = \mathsf{L}(P^{\spadesuit}, W), c \in \mathsf{L}(P^{\heartsuit}, W)  \}
\]

\[
\mathsf{P}^{\text{suit}}(w) = \begin{cases}
1 & \mathsf{a}_t(w) = \text{suit} \\
0 & else
\end{cases}
\]

Let's implement this in `R`:

```{r}
Amap_cast <- function(a){
  function(W){
    Map(a, W)
  }
}

Lsuit_cast <- function(suit){
  a_cast("context", "suit") %>%
    p_cast(`==`, suit) %>%
    l_cast()
}

min_op <- function(A, L){
  force(A); force(L)
  function(w) {
    Reduce(min, A(L(w)))
  }
}

A_s    <- Amap_cast(a_s)
A_prd  <- Amap_cast(a_cast("xy", c(1, 2)))
Lspade <- Lsuit_cast("spade")
Lheart <- Lsuit_cast("heart")


first_of <- function(what, filter){
  force(what); force(filter)
  function(w){
    min_op(what, filter)(w)
  }
}
  
first_start_of_spade <- first_of(A_s, Lspade)

fstar <- function(W){
  # Define a predicate function that indicates starts less than the first spade event
  p_cast(A_s, `>`, first_start_of_spade(W)) %>%
    # apply this function to the heart events
    { .(Lheart(W)) } %>%
    Lheart(W)[.] %>%
    { first_of(A_s, Lheart)(.) }
}

fstar(W)

```



# A Practical Toy Example

That's define a cohort where:

* the index function returns the "start of the first $\heartsuit$ after the start of the first $\spadesuit$" (i.e $\text{index}(W) = \mathsf{F}^{\star}(W)$).

```{r}
index <- fstar
```

Based on the index, we want to extract the following features about $W$:

* 2spade1heart:
  * TRUE/FALSE: Before index, does $W$ contain 2 $\spadesuit$ separated by at least 3 time units or 1 $\heartsuit$?
  * NOTE: this is analogous to a "2-out/1-in" algorithm
* foreverDiamonds:
  * TRUE/FALSE: Do the $\diamondsuit$ events have a gap of no more than 10 time units before index, starting from 25 units before index?
  * NOTE: This is analogous to a continuous enrollment algorithm
* flush: 
  * TRUE/FALSE: Is there a flush after index? I.e. any set of five consecutive events after index of the same suit.
  * Int: What is the time that the flush occurred?
  * Suit: What suit triggered the flush?
  * NOTE: the flush feature contains three data points: an indicator whether some event occurred, the time it occurred, and the type that triggered it.
* clubTrump:
  * TRUE/FALSE: Did a $\clubsuit$ occur after index?
  * Int: What is the time that the club occurred after index?
* fullOfHearts:
  * $\{Int\}$: the set of all times that $\heartsuit$ that occur before a clubTrump
  * NOTE: the feature in this case is a set of times (not just a single time)

Now let's express each of these features mathematically

## foreverDiamonds


$$
\begin{aligned}
\mathsf{L}^{\diamondsuit}(W) &= \{ w | w \in \mathsf{L}(W', \mathsf{P}^c(A_t, = \diamondsuit)  \} \\
\text{scangap} &= f(B) = \{(a', b') | (a, b) \in B, \,\, a' = \text{if }  x_{i} \leq y_{i - 1} + c \text{ then } x_{i - 1} \text{ else } x_{i} , b' = \text{if }  y_{i} \leq y_{i - 1} \text{ then } y_{i - 1} \text{ else } y_{i}, \forall i = 2, \dots, n  \} \\
\text{periods} &= g(B) = \{(a, b') | (a, b) \in f(B), \,\, b' = max(b) \,\, \forall a_i = a_j \} \\
\text{pdperiods} &= h(B, pd) = \{ (a, b) | (a, b) \in g(B), \,\, a > \mathsf{a}_s(pd), \, b < \mathsf{a}_e(pd) \} \\
\text{gaps} &= d(B, pd) = \{(a, b) | (a, b) \in B, TODO  \} \\
\text{foreverDiamonds}(W, \text{index}) &= \{\text{if } \{x | (a, b) \in d(h(A_{se}(\mathsf{L}^{\diamondsuit}), (-25, index)), x = b - a, x > 10 \} = \emptyset \text{ FALSE} \text { else } \text{TRUE} \} \\
\end{aligned}
$$

Let's look at the $\text{scangap}$ function and the patterns it can be composed of. First, we have a function performing the nuts and bolts of the set comprehension (e.g., $\text{if }  x_{i} \leq y_{i - 1} + c \text{ then } x_{i - 1} \text{ else } x_{i}$), which be somewhat kludglily patterned as:

```{r}
check_gap_cast <- function(cc = 0, pos = c(1, 2, 1, 1)) {
  function(a, b){
    if (b[pos[1]] <= (a[pos[2]] + cc)) a[pos[3]] else b[pos[4]]
  }
}
```

So that `check_gap_cast(cc = 10, pos = c(1, 2, 1, 1))` yields $f(x, y) = \text{if }  x_{i} \leq y_{i - 1} + 10 \text{ then } x_{i - 1} \text{ else } x_{i}$ and `check_gap_cast(cc = 0, pos = c(2, 2, 2, 2))` yields $f'(x, y) = \text{if }  y_{i} \leq y_{i - 1} \text{ then } y_{i - 1} \text{ else } y_{i}$.

Then we can apply that pattern to create the scangap function.

```{r}
scangap_cast <- function(cc){
  function(l){
    Reduce(
      f = function(x, y){
        c(check_gap_cast(cc, c(1, 2, 1, 1))(x, y), 
          check_gap_cast(0, c(2, 2, 2, 2))(x, y))
        },
    x = l, accumulate = TRUE)
  }
}

scangap_cast(10)(head(Wdt$xy))
```

In summary, scangap return a set of tuples the same length as the input $W$, where the start and end of each $w_i \in W$ have been updated depending on $w_{i - 1}$ extending the period until a time gap of 10 units occurs.

Now, we can identify which of those periods are the non overlapping periods by scanning the modified periods from the right, accumulating an indicator of whether each period is the longest segment of a period; then we can use set (list) comprehension to filter to the unique periods.

For example, (warning: this is klunky and could be cleaned up), but in `R`:

```{r}
# Finds the longest non-overlapping periods
scan_periods_cast <- function(cc){
  function(l){
     Map(
       function(x) as.logical(x[3]),
       Reduce(
         f = function(a, b) c(a, (a[2] + cc <= b[1]) * 1),
         x = l[-length(l)],
         init = c(l[[length(l)]], 1), accumulate = TRUE, right = TRUE)
     )
  }
}

period_cast <- function(cc){
  ff <- scan_periods_cast(cc)
  gg <- scangap_cast(cc)
  function(l){
    gg(l)[unlist(ff(gg(l)))]
  }
}

period_cast(10)(Wdt$xy)
period_cast(10)(head(Wdt$xy))
```

Now we have need a function that limits our periods to just those that overlap another period $pd$ (e.g. a lookback period). This is the $pdperiod$ function.

```{r}
pdperiod <- function(l, p){
  Filter(
    f = function(z) { !(p[2] < z[1]) && !(p[1] > z[2]) },
    x = l
  )  
}

period_cast(10)(Wdt$xy) %>% pdperiod(p = c(4, 10))
period_cast(10)(Wdt$xy) %>% pdperiod(p = c(-10, 10))
period_cast(10)(Wdt$xy) %>% pdperiod(p = c(-10, 90))
```

```{r, eval = FALSE}
# Define a couple of helper function
s <- function(p) p[1]
e <- function(p) p[2]

h <- function(p1, p2){
  if(s(p2) < s(p1) && e(p2) <= e(p1)){
    list(c(e(p2), e(p1)))
  } else if(s(p1) <= s(p2) && e(p1) < e(p2)){
    list(c(s(p1), s(p2)))
  } else if(s(p1) <= s(p2) && e(p2) <= e(p1)){
    list(c(s(p1), s(p2)), c(e(p2), e(p1)))
  } else {
    NULL
  }
}

f <- function(l, p2){
  out  <- l[-length(l)]
  p1   <- l[[length(l)]]
  hold <- h(p1, p2)
  append(out, hold)
}

h(c(1, 10), c(0, 5))
h(c(1, 10), c(2, 5))
h(c(1, 10), c(0, 11))

pds <- list(
  c(2, 5),
  c(10, 15),
  c(16, 17)
)

gap_cast <- function(pd){
  function(periods){
    Reduce(f, periods, init = list(pd))
  }
}


```


```{r, eval = FALSE}
shift_period <- function(p, x){
  x + p
}

lookback <- shift_period(c(-25, 0), index(W))

preindex_gaps <- gap_cast(lookback)

# period_cast(10)(Wdt$xy) %>% 
#   clip_period(p = lookback) 
# 
# h(lookback, c(1, 67))
# %>%
#   Reduce(f, ., init = list(lookback))
```


Now let's build foreverDiamonds
```{r, eval = FALSE}
Ldiamond <- Lsuit_cast("diamond")

foreverDiamonds <- function(W){
  Ldiamond(W) %>% 
    A_prd %>% 
    { period_cast(10)(.) } %>%
    preindex_gaps %>%
    { length(.) > 0}
}

foreverDiamonds(W)
```

Note that another pattern emerged! `Lw` is exactly the same pattern as the first part of `index`! 

* $\text{fullHouse}(W, \text{index})$
* $\text{postClubs}(W, \text{index})$

# Cohort

A cohort is a function mapping a population ($\{W_1, \dots, W_m\}$) and a specification to a set of features:

\[
\Upsilon: (Pop, S) \mapsto \{D_1, \dots, D_{m^{\star}}} \} 
\]
