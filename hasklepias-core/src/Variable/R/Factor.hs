{-# LANGUAGE DataKinds         #-}
{-# LANGUAGE DeriveGeneric     #-}
{-# LANGUAGE FlexibleContexts  #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE TypeFamilies      #-}
module Variable.R.Factor where

import           Data.Aeson                   (ToJSON (..))
import           Data.Text                    (Text)
import qualified Data.Vector                  as V
import           GHC.Generics                 (Generic)
import           Variable.R.SEXP

-- | Haskell representation of R's `factor`, either ordered or unordered.
-- Construct with 'factor' or 'ordered', preferably.
data Factor
  = MkFactor
      { values :: RTypeRep 'STRSXP
        -- ^ Get the @RTypeRep 'STRSXP@ backing the 'Factor'.
      , levels :: V.Vector Text
        -- ^ Get the levels of the 'Factor'. In R these cannot include 'NA'
        -- values, so 'levels' is of type @Vector Text@ instead of @RTypeRep
        -- 'STRSXP@.
      }
  deriving (Generic, Show)

instance ToJSON Factor

-- TODO a candidate for some optimization.

-- | Constructor for 'Factor'. 'as_character' is called on the first argument.
-- User provided 'levels' in the second argument are sorted and made unique
-- with 'VA.sortUniq'. 
--
-- Important: As in R, elements of the input vector that do not appear among
-- the 'levels' (after conversion with 'as_character') are marked as invalid,
-- here represented by 'Nothing'. That check has an \(O(nm)\) runtime cost,
-- where n is the length of the input and m the length of the levels. 
--
-- To avoid that cost, users can use 'MkConstructor' directly but must
-- themselves ensure all 'values' appear in the 'levels'.
factor :: (Show (SEXPElem s)) => RTypeRep s -> V.Vector Text -> Factor
factor rv lvls = MkFactor rv' lvls'
  where lvls' = sortUniq lvls
        rv' = V.map op $ as_characterV rv
        op Nothing = Nothing
        op (Just x) = if V.elem x lvls then Just x else Nothing

-- | Constructor for 'Factor' from a list. See 'factor'.
factorL :: (Show (SEXPElem s)) => [Maybe (SEXPElem s)] -> [Text] -> Factor
factorL rv lvls = factor (V.fromList rv) (V.fromList lvls)

-- TODO would like to have levels sorted by the ordering of the 'values' here.
-- easy if the levels are autogenerated, but otherwise you are left with
-- expensive implementations. can be added as part of an optimization pass on
-- 'factor' --bbrown

-- | Constructor for an ordered 'Factor', which is just an alias for 'factor'
-- with the extra 'Ord' constraint for clarity. Note that unlike in R, 'levels'
-- are not sorted by the ordering of the 'values'.
ordered :: (Ord (SEXPElem s), Show (SEXPElem s)) => RTypeRep s -> V.Vector Text -> Factor
ordered = factor

-- | Constructor for an ordered 'Factor' from a list. See 'ordered'.
orderedL :: (Ord (SEXPElem s), Show (SEXPElem s)) => [Maybe (SEXPElem s)] -> [Text] -> Factor
orderedL = factorL
