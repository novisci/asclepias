:toc: left
:hide-uri-scheme:
= `monarch`, a prototype
`monarch` is a tool for specifying test routines via csv, geared toward `asclepias` users. Currently it is a prototype, a starting point for discussion about what functionality `asclepias` users would like from such a tool and about how best to design a text-based user interface.

It is simply a test-configuration interface, with two main benefits:

* **Type-safety**: Haskell programmer defines a schema for the csv test data files constraining the shape and values that can be entered. 
* **Direct access for non-Haskellers**: Non-programmers are given limited but direct access to specify how functions written in Haskell should be tested, without needing to engage with the language itself.

== Features

. Given a function mapping some user-defined Haskell types `input` to `output`, allows the user to specify in `csv` format some data to provide as input and the expected output. `monarch`: 
  .. converts the `csv` data to the appropriate types, 
  .. runs the function on the inputs, 
  .. compares the function result to the outputs via a testing framework,
  .. reports results.
.  Uses a subset of the Dhall configuration language and its `dhall-csv` interpreter. Each cell value must be parseable as one of the following types, which are type-checked by the Dhall interpreter:
  .. `Text`
  .. `Integer`
  .. `Natural`
  .. `Double`
  .. `Bool` 
  .. a user-defined sum type with at most one value of the types listed above in each variant, e.g. `This | That Integer` in Haskell or Dhall syntax.
  .. a user-defined type that simply wraps one of the types above, e.g. `newtype Thing = MkThing Integer`.
. Provides ready-to-use conversions from the flat `csv` format for the core `asclepias` types defined in `event-data-theory`, such as `Event`:
  .. project-specific types that are special cases of the `event-data-theory` types need only specify the function from `input` to `output`,
  .. along with a schema dictating the concrete types used for values, e.g. `Text` for the `Context` values of an `Event`.
. For non-standard types, allows users to define how the flat `csv` data must be marshalled into the `input` and `output` types to be tested.
. Conversions to the appropriate internal types for supported custom types, such as newtype wrappers or sum types, can be provided automatically by `deriving Generic` and specifying `instance FromDhall` in the project's Haskell code.


== Non-features

. Users currently must specify input and output csv files associated with each test routine, with no helpers or naming conventions to read those files automatically from the filesystem.
. Does not allow the user to derive the flat-format-to-Haskell conversion generically for arbitrary Haskell types. These must be implemented by hand for any type not among those `monarch` implements itself, and only those that can be flattened and marshalled via `dhall-csv` are supported.
. Does not support csv cell-value types that are recursive or containers, e.g. lists.
. Is not a programming language and for example does not support functions as text input.
. Only supports single-element `Concepts` sets within the `Context` and `Event` types of `event-data-theory` because of a limitation in `dhall-csv`.
. Golden tests, in which expected and actual outputs are compared as text files, are the only ones implemented. It would be simple to extend support to unit tests, and possible with some work to extend support for property-based tests.


== How-to, with pre-defined types
This walks through how to run a test with `monarch` when the project types are special cases of those in `event-data-theory`. The full code is in the `Examples.Simple` module, which can be run from the `asclepias` repo with `cabal run monarch`.

=== Set-up
This section is a dummy setup for a project using `asclepias`. The code is not `monarch`-specific.

Suppose you have the following input types
[source,haskell]
----
data TrueFacts = Awesome | NotAwesome Text deriving (Show, Eq, Generic)
type ProjEvent = Event Text TrueFacts Integer
type Index = Interval Integer
----

where `Event c m a` is defined in `EventDataTheory.Core`. An `Event` is an `Interval` (from `interval-algebra`) with some `Context` type meta-data. For example, 

[source,haskell]
----
f1 :: TrueFacts
f1 = Awesome

c1 :: Concepts Text
c1 = packConcepts ["yay"]

e1 :: ProjEvent
e1 = event (beginerval 0 1) (context c1 f1 Nothing)
----

prints as an `Event` with interval `(1, 2)` and a `Context` with contained `Contepts` of type `Text` with value `"yay"`, a facts field of type `TrueFacts` and value `Awesome`, and `Nothing` in the source field.

----
MkEvent {(1, 2), MkContext {getConcepts = MkConcepts (fromList [MkConcept "yay"]), getFacts = Awesome, getSource = Nothing}}
----

Our output type is defined as 

[source,haskell]
----
data SumminElse = WasBefore | WasAfter deriving (Show, Eq, Generic)
type ProjOccurrence = Event Text SumminElse Integer
----

Our 'cohort-building' routine that we want to test, call it `cohortBuilder`, will take a list of `ProjEvent` and check whether the endpoints of the contained intervals are after the endpoint of the `index` interval, `(0, 1)`. `cohortBuilder` will return the input intervals with their facts field changed to type `SumminElse`, with value `WasAfter` if so and `WasBefore` otherwise.

For example, 
[source,haskell]
----
index :: Index
index = beginervalMoment 0

e1Out :: [ProjOccurrence]
e1Out = cohortBuilder index [e1]
----

gives 

----
[MkEvent {(1, 2), MkContext {getConcepts = MkConcepts (fromList [MkConcept "yay"]), getFacts = WasAfter, getSource = Nothing}}]
----

=== Highlevel step-by-step

. Define a `.dhall` schema for the flattened version of the `input` and `output` types you want to test.
. Specify one or more `Routine` s in Haskell code, which tell `monarch` what types you want to test, where to find the flat-format schema along with the associated csv file inputs.
  .. If using custom types as values for the provided `event-data-theory` types, e.g. `SumminElse` in the example above, you must ensure they satisfy the necessary conditions for `monarch` to marshall them from csv.
  .. Such conversions almost always can be generically derived. See below.
  .. Define a `ToOutput input output` instance, whose only method `toOutput` provides the transformation you want to test --- in the example above, it is `cohortBuilder index`.
. Build a `TestTree` using `monarchTest` and run it within the `Test.Tasty` framework.

=== End-goal
To run a test, `monarch` requires us to define a `Routine`, defined as 

[source,haskell]
----
type RoutineContext input output
  = (ToJSON input, ToJSON output, Testable input output)

data RoutineElem a = MkRoutineElem
  { csvFile     :: String
  , dhallSchema :: String
  }
  deriving (Show, Eq)

data Routine
  = forall input output
  . (RoutineContext input output) =>
    Golden (RoutineElem input) (RoutineElem output)
----

In words, a `Routine` is any pair of types `input` and `output` with associated csv input and Dhall schema for that csv. The pair of types must be serializable to `JSON` -- in which golden files will be written for comparison -- and must be `Testable`. The latter requires a `ToOutput` instance with the conversion from `input` to `output`, as well as requiring that both types be convertable from an internal flat record representation of the csv input.footnote:testmodes[Note that currently only golden tests are supported, as suggested by `Routine` 's single constructor `Golden`. We can add testing modes by adding additional constructors, perhaps `Unit`, and writing the associated test runners.]

Once specified, `Routine` s can be run within the `Test.Tasty` framework using the provided `monarchTest` function, which builds the `TestTree` type used in `Test.Tasty`. For example,

[source,haskell]
----
import           Test.Tasty
import           Test.Tasty.Monarch

tests :: TestTree
tests = testGroup
  "Examples.Simple"
  [ hTest "good" myRoutine
  , hTest "bad"  myBadRoutine
  , hTest "ugly" myMisspecRoutine
  ]
----

`tests` can now be run in a test routine with `Test.Tasty` 's `defaultMain` function, for example.

=== Step 1: Define Dhall schema

Schema are defined in a `.dhall` file and have the Dhall record format required for `dhall-csv`:
[source,dhall]
----
List {col1 : T, col2 : S, ...}
----

where `col1, col2` are the column names and `T`, `S` are one of the supported types listed above.

A schema is needed for each `input` and `output` type. The column names are defined by how the Haskell `input` and `output` are flattened to the record shape above. Types are determined by the particular concrete types used in the function to be tested.

Continuing with `Examples.Simple`, any schema for an `input` or `output` type of `[Event c m a]` must have the shape
[source,dhall]
----
List { concepts : C, facts : M, begin : A, end : A }
----

where `concepts` is a single `Concept` value of type `C` held within the `Context` element of `Event`, `facts` holds the fact of type `M` from `Context` and `begin`, `end` are the begin and end points of the interval of type `A`.

Type `C` corresponds to type `c` from `Event c m a` and likewise for the others.

Recall the example input type `ProjEvent` above
[source,haskell]
----
data TrueFacts = Awesome | NotAwesome Text deriving (Show, Eq, Generic)

type ProjEvent = Event Text TrueFacts Integer
----

The schema for `[ProjEvent]` is
[source,dhall]
----
List { concepts : Text, facts : < Awesome | NotAwesome : Text >, begin : Integer, end : Integer }
----

A csv file corresponding to this schema would be

----
concepts,facts,begin,end
"home","is_funny",0,4
"not home",Awesome,1,10
----

Note the constructor is not used for the `NotAwesome` variant containing a `Text` value. That is `dhall-csv` behavior.

=== 2. Specify the `Routine` s, satisfying constraints
The following code uses the `Golden` constructor to create a `Routine` pointing to schema and csv files while specifying the `input` and `output` types.footnote:pathinfix[The `</>` infix operator from the `filepath` package combines two filepaths appropriately.]

[source,haskell]
----
projPath :: String
projPath = "monarch/src/Examples"

inputCsv, outputCsv :: String
inputCsv = projPath </> "input.csv"
outputCsv = replaceFileName inputCsv "output.csv"

inputDhall, outputDhall :: String
inputDhall = projPath </> "input.dhall"
outputDhall = replaceFileName inputCsv "output.dhall"

myRoutine :: Routine
myRoutine = Golden (MkRoutineElem @[ProjEvent] inputCsv inputDhall)
                   (MkRoutineElem @[ProjOccurrence] outputCsv outputDhall)
----

To satisfy the constraints for `Golden`, we must at a minimum declare a `ToOutput` instance for the function we want to test. In this case it's

[source,haskell]
----
instance ToOutput [ProjEvent] [ProjOccurrence] where
  toOutput = cohortBuilder index
----

In addition, we must ensure our types satisfy the `RoutineContext` constraints. Had we used only one of the core supported types within `ProjEvent` and `ProjOccurrence`, the `ToOutput` instance would be all we need do.

However, the custom sum types used in the facts fields mean we need to declare a few instances. We can get the necessary conversion instances by using the generically derived `To/FromJSON` and `To/FromDhall` instances:

[source,haskell]
----
instance FromDhall TrueFacts
instance ToDhall TrueFacts
instance ToJSON TrueFacts
instance FromJSON TrueFacts

instance FromDhall SumminElse
instance ToDhall SumminElse
instance ToJSON SumminElse
instance FromJSON SumminElse
----

And that's all. Future versions of `monarch` might include a convenience tools so that one could specify a certain directory convention and run all tests in the directories automatically, rather than having to specify each one.

Note you can specify tests with different input and output data using the same schema and types by changing the csv filepath in the `RoutineElem` construction.

=== 3. Build a `TestTree` and run it.
You can now run the tests in some executable from within the `Test.Tasty` framework.footnote:tastymain[See `Main.hs` for the code included in these examples.] `monarchTest` constructs a `TestTree`, the main test object from `Test.Tasty`, from one or more `Routine` s. The `Test.Tasty` function `testGroup` constructs a `TestTree` from a list of them.

[source,haskell]
----
import           Examples.Simple
import           Test.Tasty
import           Test.Tasty.Monarch

tests :: TestTree
tests = testGroup
  "my tests"
  [ monarchTest "good" myRoutine
  ]
----

The tests can now be run within a larger test runner, which might include non-`monarch` tests, or directly via `defaultMain` from `Test.Tasty`

[source,haskell]
----
main :: IO ()
main = defaultMain tests
----

== Gotchas

* Empty values: Empty csv cells will be interpreted as empty `Text` strings. If `Text` is not the specified value type, the interpreter will throw an exception. Otherwise, the empty string will typecheck. That is true also for custom sum-type variants that hold `Text`. 
* Csv as list input: In most cases, your `input` type should be a list `[a]` for some type `a` and similarly for `output`. That is because all of the pre-built conversions for `event-data-theory` types marshall csv to lists, e.g. `[Event c m a]`. In addition, `monarch` processes *all* csv input as a list of an internal `Map` type. However, you could write a custom conversion that performs some grouping operation, say, such that one or both of the `input` and `output` types is not a list.
* Singleton `Concepts`: The `event-data-theory` type is a wrapped `Set`, but `monarch` only supports a singleton. This is a limitation of `dhall-csv`, which does not support list-like values in csv cells. However, one could augment the `Concepts c` and related schema to include a grouping column, specifying which cells should be collected into a set. Internally, `monarch` is prepared for such an implementation or similar.
* Custom `Concepts` value types must implement `Ord`. This is a requirement of `event-data-theory` which in turn is required by `Set`.

== Pre-built schema reference
Schema shapes for the supported `event-data-theory` types.

Lower-case Haskell type parameters should correspond to the upper-case Dhall type parameters. For example, if `c` is a sum type with variants `One | Two` then the dhall type `C` should be declared as `< One | Two >`.

Invalid types or field names should result in a type-check or parse error.

==== `[Concepts c]`
[source,dhall]
----
List { concepts : C }
----

==== `[Context c m]`
[source,dhall]
----
List { concepts : C, facts : M }
----

==== `[Interval a]`
[source,dhall]
----
List { begin : A, end : A }
----

==== `[PairedInterval (Concepts c) a]`
[source,dhall]
----
List { concepts : C, begin : A, end : A }
----

==== `[Event c m a]`
Note the `Source` field of `Event` is for the moment ignored. Support for it could be added easily.
[source,dhall]
----
List { concepts : C, facts : M, begin : A, end : A }
----
