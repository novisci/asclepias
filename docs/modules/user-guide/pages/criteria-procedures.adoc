:description: The procedure for creating criteria

A `Criteria` is a set of `criterion`.
Each `criterion` is a tuple,
`(Text, Status)`,
where the `Text` value represents a label
and the `Status` is either `Include` or `Exclude`.

`excludeIf` and `includeIf` are helper function
that take in a `Bool` and return a `Status`.
`exludeIf False` returns `Include` and
`excludeIf True` returns `Exclude`. 
`includeIf`, given the same inputs,
returns the opposite `Status` values.

*TODO are list of criteria connected with "AND" or "OR"?*

`CohortSpec` requires a function that
takes in the `IndexSet` and 
the shape of the input data and
returns the `Criteria`. 
Instuctions on creating `Criteria` follow.

*Creating Criteria from an Event*

*It looks like all of the criteria functions actually*
*produce features? But these features don't appear*
*in the feature runner, so I'm not sure they*
*actually appear in the output? if so, why*
*make these features at all?*

[source,haskell]
----
{-
Include the subject if over 50; Exclude otherwise.
-}
critOver50 :: Def (F "ageAtIndex" Integer -> F "isOver50" Status)
critOver50 = define (includeIf . (>= 50))

{- 
Include a unit if:
  * continuously enrolled during 365 days up to index with
    gaps of <= 8 days.
-}
critContEnrolled
  :: Def
       (  F "index" (Interval Day)
       -> F "allEvents" (Es Day)
       -> F "isOver50" Status
       -> F "continuousEnrollment" Status
       )
critContEnrolled = buildContinuousEnrollment
  (makeBaselineMeetsIndex 365) -- look during year up to index
  (liftToEventPredicate isEnrollmentDomain) -- for enrollment events
  8 -- allowable gap
----

*Creating Criteria from non-Event Data*

This assumes that your IndexSet and 
input data shape are already defined.

. Review the SAP for the inclusion/exclusion criteria.
. Create a function for each criterion that return a `Bool`.
. Define your criteria function.
    . Define your criteria function type,
    `a -> YourInputData -> Criteria`, where `a` is your IndexSet type and YourInputData is your input data type.
    . Apply the correct pattern matching for your input data.
    . Define the function output as `criteria [yourCriterionList]`
    where yourCriterionList is constructed as 
    "`criterion` yourLabel (`includeIf`/`excludeIf` yourBoolFunction)"

The example below takes in an empty index set,
and `InputData` and creates `criteria` where
the `Status` is `Include` if the boolean value that
is contained in `InputData` is `False`,
otherwise `Exclude` is returned.

[source,haskell]
----
type YourInputData = (Bool, Integer)

yourIndex :: YourInputDataType -> IndexSet ()
yourIndex _ = makeIndexSet [()]

yourCriteria :: () -> YourInputData -> Criteria 
yourCriteria myIndex (b, n) = 
    criteria 
     [ criterion "include if b = True" (includeIf b)
     , criterion "include if n > 5" (includeIf (n > 5))
     ]
----

