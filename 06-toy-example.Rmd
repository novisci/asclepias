
# Toy Example

First some useful concepts. We can define a sequence of *distinct* (non-overlapping) intervals as a monoid, a set closed under associative binary operator that has an identity element. NOTE: I think this is *not* a commutative monoid, 

$$
\begin{align*}
[\Xi] + [] = [\Xi] \\
[] + [\Xi] = [\Xi] \\
[\Xi] + [\Xi'] =
flatten[head([\Xi]), tail([\Xi]) + head([\Xi']), tail([\Xi])])
\end{align*}
$$
where I'm being loose with $tail$ and $head$ ($tail(\Xi)$ is the *last* element of $[\Xi]$ and $head(\Xi')$ is the *first* element of $[\Xi']$) and the sum of two intervals is defined as $\Xi + \Xi'$ is defined as 

$$
\Xi + \Xi' = (a, b) + (c, d) = \begin{cases}
[(a, d)] & c \leq d 
[(a, b), (c, d)] &  else
\end{cases}
$$





This example uses data for the single subject defined above to define a $n = 1$ feature set. The subject's index event is defined as the start of the first $\heartsuit$ after the start of the first $\spadesuit$ (i.e $\text{index}(W) = \mathsf{F}^{\star}(W)$).

```{r}
index <- fstar
```


Define the following features:

|   Feature       |   Definition       |   Analogy   |
|-----------------|--------------------|-------------|
| 2spade1heart    | Indicate whether, before index, there are 2 $\spadesuit$ event whose starts are separated by at least 3 time units *or* 1 $\clubsuit$ | "2-out/1-in" |
| foreverDiamonds | Indicate whether, after joining all overlapping or adjoined events, the $\diamondsuit$ events have a gap of no more than 5 time units in the time between 25 units before index and up to index | continuous enrollment | 
| flush | Indicate whether there is a flush after index; i.e. any set of five consecutive events after index of the same suit. If a flush occurred, keep the time that the flush occurred *and* what suit triggered the flush. | time to event outcome variable| 
| clubTrump    | Indicate if a $\clubsuit$ occurs after index. If so, keep the time that the first club occurred. | censoring variable |
| fullOfHearts | The set of all $\heartsuit$ event start times that occur between index and clubTrump | longitudinal data | 

Now let's express each of these features mathematically.


## 2spade1heart

Let's define a few more functions that operate on $w$ and $\Xi$.

| Definition     | Mapping                      | Description        |
| ------------   | ---------------------------- | ------------------ |
| $any(W) = \begin{cases} W \neq \emptyset & TRUE \\ else & FALSE \end{cases}$  | $any : \mathcal{W} \mapsto \mathbb{B}$ | Is $W$ empty? | 


```{r}
ANY <- function(x) length(x) > 0

compare_head_to_tail_cast <- function(compareFUN){
  
  force(compareFUN)
  
  f <- function(el){
    switch(
      EXPR = as.character(length(el)),
      "0"  = list(),
      "1"  = list(FALSE),
      Map(function(x, h) { compareFUN(x, h = h) }, el[-1L], h = el[1L]) %>%
        Reduce(`|`, .) %>% list() %>% append(f(el[-1L])))
  }
  
  f

}

compare_function_cast <- function(relation, bound){
  function(x, h){
    relation( s(x) - s(h), bound)
  }
}

t2spade1heart <- function(W){
  a_cast(c("interval", "a")) %>%
   p_cast(`<`, index(W)) %>%
    l_cast() %>%
    {
     {.(Lsuit_cast("spade")(W))} %>%
     {
       w <- .
       compare_function_cast(`>=`, 3) %>%
        compare_head_to_tail_cast() %>%
         { w[unlist(.(w))] } 
     } %>%
        ANY()  ||
     {.(Lsuit_cast("club")(W))} %>%
        ANY()
    }
}

# No clubs before index
W1 <- W[-7]
W3 <- W2 <- W1
W2[[6]] <- event(interval = interval(a = 17L, b = 17L), 
               context = context(suit = suit("spade"), value = "2"))
W3[[5]] <- event(interval = interval(a = 8L, b = 8L), 
               context = context(suit = suit("spade"), value = "2"))

t2spade1heart(W)
t2spade1heart(W1)
t2spade1heart(W2)
t2spade1heart(W3)

```

This code will certainly be cleaned up, a key point is that the function is composed of a pattern: `filter W -> apply function`:

```
        clubs         spades
           |            |
             before index   
           |            | 
          id         has gaps > 3  
           |            |
          any          any
            \          /
                 or
```

The key this project is identifying and exploiting such patterns.

Towards a configuration:

```
filters:
   A: starts of clubs before index
   B: starts of spades with a pairwise distance of starts > 3 before index 
features:
   id: any A or any B
```

## foreverDiamonds

```
any periods of diamonds


```

$$
\begin{aligned}
\mathsf{L}^{\diamondsuit}(W) &= \{ w | w \in \mathsf{L}(W', \mathsf{P}^c(A_t, = \diamondsuit)  \} \\
\text{scangap} &= f(B) = \{(a', b') | (a, b) \in B, \,\, a' = \text{if }  x_{i} \leq y_{i - 1} + c \text{ then } x_{i - 1} \text{ else } x_{i} , b' = \text{if }  y_{i} \leq y_{i - 1} \text{ then } y_{i - 1} \text{ else } y_{i}, \forall i = 2, \dots, n  \} \\
\text{periods} &= g(B) = \{(a, b') | (a, b) \in f(B), \,\, b' = max(b) \,\, \forall a_i = a_j \} \\
\text{pdperiods} &= h(B, pd) = \{ (a, b) | (a, b) \in g(B), \,\, a > \mathsf{a}_s(pd), \, b < \mathsf{a}_e(pd) \} \\
\text{gaps} &= d(B, pd) = \{(a, b) | (a, b) \in B, TODO  \} \\
\text{foreverDiamonds}(W, \text{index}) &= \{\text{if } \{x | (a, b) \in d(h(A_{se}(\mathsf{L}^{\diamondsuit}), (-25, index)), x = b - a, x > 10 \} = \emptyset \text{ FALSE} \text { else } \text{TRUE} \} \\
\end{aligned}
$$

Let's look at the $\text{scangap}$ function and the patterns it can be composed of. First, we have a function performing the nuts and bolts of the set comprehension (e.g., $\text{if }  x_{i} \leq y_{i - 1} + c \text{ then } x_{i - 1} \text{ else } x_{i}$), which be somewhat kludglily patterned as:

```{r}
check_gap_cast <- function(cc = 0, pos = c(1, 2, 1, 1)) {
  function(a, b){
    if (b[pos[1]] <= (a[pos[2]] + cc)) a[pos[3]] else b[pos[4]]
  }
}
```

So that `check_gap_cast(cc = 10, pos = c(1, 2, 1, 1))` yields $f(x, y) = \text{if }  x_{i} \leq y_{i - 1} + 10 \text{ then } x_{i - 1} \text{ else } x_{i}$ and `check_gap_cast(cc = 0, pos = c(2, 2, 2, 2))` yields $f'(x, y) = \text{if }  y_{i} \leq y_{i - 1} \text{ then } y_{i - 1} \text{ else } y_{i}$.

Then we can apply that pattern to create the scangap function.

```{r}
scangap_cast <- function(cc){
  function(l){
    Reduce(
      f = function(x, y){
        c(check_gap_cast(cc, c(1, 2, 1, 1))(x, y), 
          check_gap_cast(0, c(2, 2, 2, 2))(x, y))
        },
    x = l, accumulate = TRUE)
  }
}

scangap_cast(10)(head(Wdt$xy))
```

In summary, scangap return a set of tuples the same length as the input $W$, where the start and end of each $w_i \in W$ have been updated depending on $w_{i - 1}$ extending the period until a time gap of 10 units occurs.

Now, we can identify which of those periods are the non overlapping periods by scanning the modified periods from the right, accumulating an indicator of whether each period is the longest segment of a period; then we can use set (list) comprehension to filter to the unique periods.

For example, (warning: this is klunky and could be cleaned up), but in `R`:

```{r}
# Finds the longest non-overlapping periods
scan_periods_cast <- function(cc){
  function(l){
     Map(
       function(x) as.logical(x[3]),
       Reduce(
         f = function(a, b) c(a, (a[2] + cc <= b[1]) * 1),
         x = l[-length(l)],
         init = c(l[[length(l)]], 1), accumulate = TRUE, right = TRUE)
     )
  }
}

period_cast <- function(cc){
  ff <- scan_periods_cast(cc)
  gg <- scangap_cast(cc)
  function(l){
    gg(l)[unlist(ff(gg(l)))]
  }
}

period_cast(10)(Wdt$xy)
period_cast(10)(head(Wdt$xy))
```

Now we have need a function that limits our periods to just those that overlap another period $pd$ (e.g. a lookback period). This is the $pdperiod$ function.

```{r}
pdperiod <- function(l, p){
  Filter(
    f = function(z) { !(p[2] < z[1]) && !(p[1] > z[2]) },
    x = l
  )  
}

period_cast(10)(Wdt$xy) %>% pdperiod(p = c(4, 10))
period_cast(10)(Wdt$xy) %>% pdperiod(p = c(-10, 10))
period_cast(10)(Wdt$xy) %>% pdperiod(p = c(-10, 90))
```

```{r, eval = FALSE}
# Define a couple of helper function
s <- function(p) p[1]
e <- function(p) p[2]

h <- function(p1, p2){
  if(s(p2) < s(p1) && e(p2) <= e(p1)){
    list(c(e(p2), e(p1)))
  } else if(s(p1) <= s(p2) && e(p1) < e(p2)){
    list(c(s(p1), s(p2)))
  } else if(s(p1) <= s(p2) && e(p2) <= e(p1)){
    list(c(s(p1), s(p2)), c(e(p2), e(p1)))
  } else {
    NULL
  }
}

f <- function(l, p2){
  out  <- l[-length(l)]
  p1   <- l[[length(l)]]
  hold <- h(p1, p2)
  append(out, hold)
}

h(c(1, 10), c(0, 5))
h(c(1, 10), c(2, 5))
h(c(1, 10), c(0, 11))

pds <- list(
  c(2, 5),
  c(10, 15),
  c(16, 17)
)

gap_cast <- function(pd){
  function(periods){
    Reduce(f, periods, init = list(pd))
  }
}


```


```{r, eval = FALSE}
shift_period <- function(p, x){
  x + p
}

lookback <- shift_period(c(-25, 0), index(W))

preindex_gaps <- gap_cast(lookback)

# period_cast(10)(Wdt$xy) %>% 
#   clip_period(p = lookback) 
# 
# h(lookback, c(1, 67))
# %>%
#   Reduce(f, ., init = list(lookback))
```


Now let's build foreverDiamonds
```{r, eval = FALSE}
Ldiamond <- Lsuit_cast("diamond")

foreverDiamonds <- function(W){
  Ldiamond(W) %>% 
    A_prd %>% 
    { period_cast(10)(.) } %>%
    preindex_gaps %>%
    { length(.) > 0}
}

foreverDiamonds(W)
```

Note that another pattern emerged! `Lw` is exactly the same pattern as the first part of `index`! 

## flush

* $\text{flush}(W, \text{index})$

## clubTrump

* $\text{clubTrump}(W, \text{index})$

## fullOfHearts


