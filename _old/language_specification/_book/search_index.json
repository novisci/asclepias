[["index.html", "Project Asclepias Preface", " Project Asclepias Preface ETC "],["design.html", "Chapter 1 Design 1.1 What is does not do 1.2 From here", " Chapter 1 Design @CITE writes: “One of the important advantages of having a mathematical model for programming is that it’s possible to perform formal proofs of correctness of software. This might not seem so important when you’re writing consumer software, but there are areas of programming where the price of failure may be exorbitant, or where human life is at stake.” In epidemiology and medicine, programming errors can cost lives. Project Asclepias aims to formalize one aspect of the research pipeline: implementing the study plan. @CITE writes: “Functional programmers have a peculiar way of approaching problems. They start by asking very Zen-like questions. For instance, when designing an interactive program, they would ask: What is interaction?” In that vein, what is a cohort? Asclepias defines a cohort \\(C\\) as the output of a mathematical function. Let \\(P\\) be a population and \\(S\\) be a study design that specifies a cohort’s inclusion/exclusion criteria and the set of features needed for analysis. The cohort building function maps a population and a specification to a cohort: \\[ \\Upsilon: (P, S) \\mapsto C \\] This formulation obviously leaves out a lot of details. \\(\\Upsilon\\) will be composed of many other functions and the structure of \\(P\\), \\(S\\), and \\(C\\) need to be described. Asclepias takes a functional approach to cohort building. Existing approaches and cohort building languaage are algorithmic by describing the steps. And while all functions are algorithms not all algorithms are functions. Why does this make a difference? With the goals of: providing a structured language of cohort building that can declare designs from simple to complex reducing the time between planning and execution of analyses providing software that can be scaled to handle massive datasets (?) validated software for a regulated industry 1.1 What is does not do Asclepias does not check that the plan itself is sound or that the population is relevant to the study question. 1.2 From here described at a big picture now going to describe from inside out outline core data types A cohort builder \\(\\zeta\\) is a function mapping a population to a cohort: \\[ \\zeta: P \\mapsto C \\] A cohort planner is a function \\(\\Lambda\\) that maps a specification \\(S\\) to a cohort builder. \\[ \\Lambda: S \\mapsto ( \\zeta : P \\mapsto C ) \\] The next 4 chapters describe the design of \\(P\\) and data types it is composed of \\(\\zeta\\) and the function types it is composed of \\(C\\) and the data types it is composed of Before demostrating a complete working example starting from \\(S\\) and \\(\\Lambda\\), we first explain how \\(\\zeta\\) works with toy example building a cohort “by hand” using the types \\(S\\) and how a specification defines all of the above "],["data-types.html", "Chapter 2 Data Types 2.1 Interval 2.2 Context 2.3 Contextualized Set 2.4 Events 2.5 Event History 2.6 Subject 2.7 Population", " Chapter 2 Data Types The data types formalized here will mostly be familiar to epidemiologists. 2.1 Interval An interval \\(\\Xi\\) is as an ordered pair defining the start and end of a segment on the integer line. \\[ \\Xi := (a, b) \\mid a \\leq b \\in \\mathbb{Z} \\] Let \\(\\mathcal{I}\\) be the set of all \\(\\Xi\\). Here’s a few \\(\\Xi\\)s represented visually: To make the math concrete, define data structures in a programming language (in this case R) that align with our mathematical definition. itv &lt;- interval(a = 2L, b = 4L) itv ## (2, 4) We’re going to get into functions later, but a few basic functions might help contextualize what we can do with the interval data structure. Definition Mapping Description \\(s(\\Xi) = a\\) \\(s : \\mathcal{I} \\mapsto \\mathbb{Z}\\) Gets the interval’s start \\(e(\\Xi) = b\\) \\(e : \\mathcal{I} \\mapsto \\mathbb{Z}\\) Gets the interval’s end \\(shift(\\Xi, c) = (s(\\Xi) + c, e(\\Xi) + c)\\) \\(shift : (\\mathcal{I}, \\mathbb{Z}) \\mapsto \\mathcal{I}\\) Shifts an interval by \\(c\\) \\(expandl(\\Xi, c) = (s(\\Xi) - c, e(\\Xi))\\) \\(expandl : (\\mathcal{I}, \\mathbb{Z}) \\mapsto \\mathcal{I}\\) Expands an interval to the left by \\(c\\) \\(expandr(\\Xi, c) = (s(\\Xi), e(\\Xi) + c)\\) \\(expandr : (\\mathcal{I}, \\mathbb{Z}) \\mapsto \\mathcal{I}\\) Expands an interval to the right by \\(c\\) \\(expand(\\Xi, c) = (s(\\Xi) - c, e(\\Xi) + c)\\) \\(expand : (\\mathcal{I}, \\mathbb{Z}) \\mapsto \\mathcal{I}\\) Expands an interval by \\(c\\) \\(length(\\Xi) = e(\\Xi) - s(\\Xi)\\) \\(length : \\mathcal{I} \\mapsto \\mathbb{Z}\\) Measures the length of an interval \\(flipl(\\Xi) = (s(\\Xi) - length(\\Xi), s(\\Xi))\\) \\(flipl : \\mathcal{I} \\mapsto \\mathbb{Z}\\) Flips an interval to the left \\(flipr(\\Xi) = (e(\\Xi), e(iota) + length(\\Xi))\\) \\(flipr : \\mathcal{I} \\mapsto \\mathbb{Z}\\) Flips an interval to the right \\(ennummerate(\\Xi) = \\{z \\mid z \\in \\mathbb{Z}, z &gt;= s(\\Xi), z &lt;= e(\\Xi)\\}\\) \\(ennummerate : \\mathcal{I} \\mapsto \\mathbb{Z}\\) Ennumerates all the integers in an interval \\(=(\\Xi, \\Xi&#39;) = \\begin{cases} TRUE &amp; s(\\Xi) = s(\\Xi&#39;) \\; \\&amp; \\; e(\\Xi) = e(\\Xi&#39;) \\\\ FALSE &amp; else\\end{cases}\\) \\(= : (\\mathcal{I}, \\mathcal{I}) \\mapsto \\mathbb{B}\\) determines if two intervals are equal$ \\(&lt;(\\Xi, \\Xi&#39;) = \\begin{cases} TRUE &amp; s(\\Xi) &lt; s(\\Xi&#39;) \\\\ TRUE &amp; s(\\Xi) = s(\\Xi&#39;) \\; \\&amp; \\; e(\\Xi) &lt; e(\\Xi&#39;) \\\\ FALSE &amp; else\\end{cases}\\) \\(&lt; : (\\mathcal{I}, \\mathcal{I}) \\mapsto \\mathbb{B}\\) determines if two intervals are ordered such that \\(s(\\Xi) &lt; s(\\Xi&#39;)\\) or \\(s(\\Xi) = s(\\Xi&#39;)\\) and \\(e(\\Xi) &lt; e(\\Xi&#39;)\\). \\(order( ( \\Xi, \\Xi&#39; ) ) = \\begin{cases} &lt;\\Xi, \\Xi&#39;&gt; &amp; &lt;(\\Xi, \\Xi&#39;) = TRUE \\\\ &lt; \\Xi&#39;, \\Xi &gt; &amp; &lt;(\\Xi, \\Xi&#39;) = FALSE \\end{cases}\\) \\(order : (\\mathcal{I} \\times \\mathcal{I}) \\mapsto \\mathcal{I^{2}_o}\\) where \\(\\mathcal{I}^{2}_o = \\{ &lt; \\Xi, \\Xi&#39; &gt;\\}\\) and \\(&lt;\\cdot, \\cdot&gt;\\) indicates that the pair of elements are ordered puts two intervals into order according to &lt;. \\(overlaps( &lt;\\Xi, \\Xi&#39;&gt; ) = \\begin{cases} TRUE &amp; s(\\Xi&#39;) \\leq e(\\Xi) \\\\ FALSE &amp; else\\end{cases}\\) \\(overlaps : \\mathcal{I^{2}_o} \\mapsto \\mathbb{B}\\) determines if two ordered intervals overlap These functions may seem trivial, but they reveal a few concepts: We’ve expressly defined the data types of each function’s input and output. Starting with simple accessor functions (\\(s\\) and \\(e\\)) and basic set, relational, and arithmetic operators, we created simple functions from which more complicated functions can be composed (as we will see). Here are the functions in action: itv &lt;- interval(a = 2L, b = 10L) s(itv) ## [1] 2 e(itv) ## [1] 10 ennummerate(itv) ## [1] 2 3 4 5 6 7 8 9 10 length(itv) ## [1] 8 flipl(itv) ## (-6, 2) flipr(itv) ## (10, 18) shift(itv, 5L) ## (7, 15) expandl(itv, 5L) ## (-3, 10) expandr(itv, 5L) ## (2, 15) expand(itv, 5L) ## (-3, 15) itv &lt; interval(a = 5L, b = 11L) ## [1] TRUE itv &lt; interval(a = 1L, b = 11L) ## [1] FALSE itv &lt; interval(a = 2L, b = 11L) ## [1] TRUE itv &lt; interval(a = 2L, b = 3L) ## [1] FALSE interval_pair(a = itv, b = interval(a = -1L, b = 10L)) %&gt;% order() %&gt;% overlaps() ## [1] TRUE interval_pair(a = itv, b = interval(a = -1L, b = 0L)) %&gt;% order() %&gt;% overlaps() ## [1] FALSE interval_pair(a = itv, b = interval(a = 2L, b = 11L)) %&gt;% order() %&gt;% overlaps() ## [1] TRUE TODO: (I think) A sequence of distinct (non-overlapping) intervals and an addition-like operator can be defined as a monoid, a set closed under associative binary operator that has an identity element. NOTE: I think this is not a commutative monoid. \\[ \\begin{align*} [\\Xi] + [] &amp;= [\\Xi] \\\\ [] + [\\Xi] &amp;= [\\Xi] \\\\ [\\Xi] + [\\Xi&#39;] &amp;= [head([\\Xi])](last([\\Xi]) + first([\\Xi&#39;])[tail([\\Xi&#39;])]) \\end{align*} \\] where I’m being loose with \\(tail\\) and \\(head\\) (\\(tail([\\Xi])\\) is the last element of \\([\\Xi]\\) and \\(head([\\Xi&#39;])\\) is the first element of \\([\\Xi&#39;]\\)) and the sum of two intervals is defined as \\(\\Xi + \\Xi&#39;\\) is defined as \\[ \\Xi + \\Xi&#39; = (a, b) + (c, d) = \\begin{cases} [(a, d)] &amp; c \\leq d \\\\ [(a, b), (c, d)] &amp; else \\end{cases} \\] Note that \\((\\Xi, +)\\) is not a monoid, but \\(([\\Xi], +)\\) is. 2.2 Context Define a context \\(\\square\\) as an associative array. TODO: formalize the notion of a context constructor such that different event “domains” can have different contexts (i.e. different keys). For example, one could define a lab results context that has keys for LOINC code, value, and units and a diagnosis context that has keys for diagnosis code, code source (ICD-10, ICD-9, etc), and clinic location. 2.3 Contextualized Set This pattern repeats throughout the design: \\[ \\{ \\square, \\cdot \\} \\] where \\(\\cdot\\) is some set. TODO: further describe this type. 2.4 Events The fundamental data structure is that of events occurring in time with information attached to the event such as a hospital stay, disease diagnosis, or lab values. We most often work on the time scale of days, so for now we’ll think about the time intervals in terms of integers. Define an event \\(w\\) as a set with an interval and a context: \\[ w := \\{\\Xi, \\square\\} \\] For the purposes of the toy example, let their be a single context type that is the pair of the suit and value of a poker card: \\[ \\square \\in \\{suit \\in \\mathcal{S} = \\{\\clubsuit, \\heartsuit, \\diamondsuit, \\spadesuit \\}, value \\in \\mathcal{V} = \\{A, 2, 3, 4, 5, 6, 7 , 8, 9, 10, J, Q, K\\}\\} \\] Let \\(\\overline{\\square}\\) be the set of all contexts specific to our study. Define a couple of accessor functions for our specific context: Definition Mapping Description \\(suit(\\square)\\) \\(suit : \\overline{\\square}\\ \\mapsto \\mathcal{S}\\) Gets the suit of a context. \\(value(\\square)\\) \\(value : \\overline{\\square}\\ \\mapsto \\mathcal{V}\\) Gets the value of a context c1 &lt;- context(suit = suit(&quot;heart&quot;), value = &quot;3&quot;) c2 &lt;- context(suit = suit(&quot;diamond&quot;), value = &quot;J&quot;) suit(c1) ## ♥ suit(c2) ## ♦ value(c1) ## [1] &quot;3&quot; value(c2) ## [1] &quot;J&quot; event(interval = itv, context = c1) ## {(2, 10), {♥, 3}} event(interval = interval(a = 4L, b = 20L), context = c2) ## {(4, 20), {♦, J}} 2.5 Event History Events are collected into an indexed, partially ordered set: \\[ W = \\{ (w_1, w_2, \\dots, w_n) \\mid \\Xi_i \\leq \\Xi_{i + 1} \\: \\forall i = 1, \\dots, n -1 \\} \\] Here’s a randomly generated set \\(W\\): ## {(8, 18), {♥, K}}, ## {(13, 14), {♠, 7}}, ## {(24, 24), {♠, 8}}, ## {(34, 38), {♠, 8}}, ## {(38, 38), {♠, 4}}, ## {(46, 46), {♦, 5}}, ## {(48, 50), {♠, 5}}, ## {(56, 56), {♥, 10}}, ## {(66, 68), {♦, 8}}, ## {(68, 76), {♦, Q}}, ## {(69, 78), {♥, Q}}, ## {(69, 78), {♥, 7}}, ## {(80, 80), {♠, 3}}, ## {(82, 82), {♦, 9}}, ## {(82, 90), {♦, 8}}, ## {(90, 90), {♦, 5}}, ## {(90, 97), {♣, 8}}, ## {(91, 96), {♦, 2}}, ## {(91, 96), {♠, 8}}, ## {(92, 100), {♦, 10}} And here’s \\(W\\) represented graphically where y-axis is used to differentiate each \\(w\\) by its suit: 2.6 Subject A subject, patient or unit is a context and an event history: \\[ U = \\{ \\square, W\\} \\] The context could contain information such as a patient ID and information that is constant over the course of the study as birth date and race. Note that this information could also be stored in event context(s) – the decision is up to the study planners. 2.7 Population A population is a context and a unordered set of subjects: \\[ P = \\{\\square, \\{U_1, \\dots, U_m \\} \\} \\] The population context may contain metadata such as when the data was generated. TODO: define a way of ordering populations? "],["function-types.html", "Chapter 3 Function Types 3.1 Accessors 3.2 Predicates 3.3 Filters", " Chapter 3 Function Types 3.1 Accessors As described above, accessor functions extract information from an event \\(w\\). For example: \\[ \\mathsf{a}_{\\Xi}(w) = (a, b); \\mathsf{a}_s(w) = (s \\circ \\mathsf{a}_{\\Xi}) (w) = a ; \\mathsf{a}_{\\square}(w) = \\square \\] Functors can also be defined that operate on collections of events, for example: \\[ \\mathsf{a}_s(W) = \\{(a_1, \\dots, a_n) | a_i = \\mathsf{a}_s(w_i) \\,\\, \\forall w_i \\in W\\} \\] 3.2 Predicates A predicate \\(\\mathsf{P}\\) is a function that returns a boolean (or \\(\\{0, 1\\}\\)) based on \\(w\\) that is constructed by an accessor and a relational operator. \\[ \\mathsf{P}^c : (\\mathsf{a}, \\cdot) \\mapsto \\mathsf{P}: w \\mapsto \\{0, 1\\} \\] where \\(a\\) is an accessor function and \\(\\cdot\\) is a relational operator. Defined similarly for a set of events: \\[ \\mathsf{P}^c : (\\mathsf{a}, \\cdot) \\mapsto \\mathsf{P}: W \\mapsto \\{\\{0, 1\\}^n\\} \\] Predicates are constructed from acessors and relations. For example, the following function returns \\(1\\) when the start of \\(w\\) is less than or equal to some constant \\(c\\): \\[ \\mathsf{P}&#39;(w) = \\begin{cases} 1 &amp; \\mathsf{a}_s(w) \\leq c \\\\ 0 &amp; else \\end{cases} \\] where \\(\\mathsf{P}&#39; = \\mathsf{P}^c(\\mathsf{a}_s, &lt; c)\\). 3.3 Filters A filter is a function \\(\\mathsf{L}\\) that subsets \\(W\\) based on a set of predicate functions \\(\\{\\mathsf{P}\\}\\). \\[ \\mathsf{L}: (\\mathsf{P}, W) \\mapsto W&#39;; W&#39; \\subseteq W \\] Here’s an example filter function that filters \\(W\\) based on \\(\\mathsf{P}&#39;\\): \\[ \\mathsf{L}&#39;(\\mathsf{P}, W) = \\{w \\in W | \\mathsf{P}&#39;(w) = 1 \\} \\] Implemented in R it might look something like this. a_i &lt;- function(w) w@interval a_s &lt;- function(w) s(a_i(w)) P1 &lt;- function(w) a_s(w) &gt; 50 L1 &lt;- function(w) Filter(P1, w) L1(W) ## [[1]] ## {(56, 56), {♥, 10}} ## [[2]] ## {(66, 68), {♦, 8}} ## [[3]] ## {(68, 76), {♦, Q}} ## [[4]] ## {(69, 78), {♥, Q}} ## [[5]] ## {(69, 78), {♥, 7}} ## [[6]] ## {(80, 80), {♠, 3}} ## [[7]] ## {(82, 82), {♦, 9}} ## [[8]] ## {(82, 90), {♦, 8}} ## [[9]] ## {(90, 90), {♦, 5}} ## [[10]] ## {(90, 97), {♣, 8}} ## [[11]] ## {(91, 96), {♦, 2}} ## [[12]] ## {(91, 96), {♠, 8}} ## [[13]] ## {(92, 100), {♦, 10}} But we can program in an more functional way and produce function molds. Here’s an example. a_cast &lt;- function(slots){ function(w){ Reduce(function(x, y) slot(x, y), slots, init = w) } } a_cast(c(&quot;interval&quot;, &quot;a&quot;))(W[[1]]) ## [1] 8 a_cast(c(&quot;context&quot;, &quot;value&quot;))(W[[1]]) ## [1] &quot;K&quot; p_cast &lt;- function(accessor, relation, bound){ force(accessor); force(bound); function(w){ relation(accessor(w), bound) } } l_cast &lt;- function(p){ force(p) function(w){ Filter(p, w) } } Which can then be composed to extract elements from \\(W\\). a_cast(c(&quot;interval&quot;, &quot;a&quot;)) %&gt;% p_cast(`&lt;=`, 10) %&gt;% l_cast() %&gt;% {.(W)} ## [[1]] ## {(8, 18), {♥, K}} "],["features-observational-units-and-cohorts.html", "Chapter 4 Features, observational units, and Cohorts 4.1 Features and Feature sets 4.2 Observational Unit 4.3 Cohort", " Chapter 4 Features, observational units, and Cohorts 4.1 Features and Feature sets A feature is a function that extracts a feature set \\(D\\) from an event history \\(W\\). Features are composed from the types of functions described above: accessors, predicates, filters, map/reduce functions, and basic arithmetic, set, and relational operators. Let \\(\\mathcal{D}\\) as the set of all possible information that could be extracted from \\(\\mathcal{W}\\). \\[ \\mathsf{F}: \\mathcal{W} \\mapsto \\mathcal{D} \\] For example, let’s define the “start of the first \\(\\heartsuit\\) after the start of the first \\(\\spadesuit\\)”. As a function of \\(W\\), this can be expressed as \\[ \\mathsf{F}^{\\star}(W) = \\min \\{ \\mathsf{a}_s(z) | z \\in W&#39; = \\mathsf{L}^{\\star}(W) \\} \\] where \\(\\mathsf{L}^{\\star}\\) filters \\(W\\) to the set of all \\(w\\) that occur after the first \\(w\\) with \\(\\spadesuit\\): \\[ \\mathsf{L}^{\\star}(W) = \\{w | \\mathsf{a}_s(c) &gt; \\min(\\mathsf{a}_s(s)), s \\in S = \\mathsf{L}(P^{\\spadesuit}, W), c \\in \\mathsf{L}(P^{\\heartsuit}, W) \\} \\] \\[ \\mathsf{P}^{\\text{suit}}(w) = \\begin{cases} 1 &amp; \\mathsf{a}_t(w) = \\text{suit} \\\\ 0 &amp; else \\end{cases} \\] NOTE: to safely implement \\(F^{\\star}\\), we’ll need to handle the empty set, \\(\\emptyset\\), but I’ll ignore this for now. Let’s implement this in R: Amap_cast &lt;- function(a){ function(W){ Map(a, W) } } Lsuit_cast &lt;- function(suit){ a_cast(c(&quot;context&quot;, &quot;suit&quot;)) %&gt;% p_cast(`==`, suit) %&gt;% l_cast() } min_op &lt;- function(A, L){ force(A); force(L) function(w) { Reduce(min, A(L(w))) } } A_s &lt;- Amap_cast(a_s) Lspade &lt;- Lsuit_cast(&quot;spade&quot;) Lheart &lt;- Lsuit_cast(&quot;heart&quot;) first_of &lt;- function(what, filter){ force(what); force(filter) function(w){ min_op(what, filter)(w) } } first_start_of_spade &lt;- first_of(A_s, Lspade) fstar &lt;- function(W){ a_cast(c(&quot;interval&quot;, &quot;a&quot;)) %&gt;% p_cast(`&gt;`, first_start_of_spade(W)) %&gt;% l_cast() %&gt;% { .(Lheart(W)) } %&gt;% { first_of(A_s, Lheart)(.) } } fstar(W) ## [1] 56 4.2 Observational Unit An observational unit is a context and a feature set: \\[ O = \\{ \\square, D \\} \\] 4.3 Cohort Cohort is a context and a feature set. \\[ C = \\{\\square, \\{O_1, \\dots, O_{m^{\\star}}\\}\\} \\] "],["toy-example.html", "Chapter 5 Toy Example 5.1 2spade1heart 5.2 foreverDiamonds 5.3 flush 5.4 clubTrump 5.5 fullOfHearts", " Chapter 5 Toy Example This example uses data for the single subject defined above to define a \\(n = 1\\) feature set. The subject’s index event is defined as the start of the first \\(\\heartsuit\\) after the start of the first \\(\\spadesuit\\) (i.e \\(\\text{index}(W) = \\mathsf{F}^{\\star}(W)\\)). index &lt;- fstar Define the following features: Feature Definition Analogy 2spade1heart Indicate whether, before index, there are 2 \\(\\spadesuit\\) event whose starts are separated by at least 3 time units or 1 \\(\\clubsuit\\) “2-out/1-in” foreverDiamonds Indicate whether, after joining all overlapping or adjoined events, the \\(\\diamondsuit\\) events have a gap of no more than 5 time units in the time between 25 units before index and up to index continuous enrollment flush Indicate whether there is a flush after index; i.e. any set of five consecutive events after index of the same suit. If a flush occurred, keep the time that the flush occurred and what suit triggered the flush. time to event outcome variable clubTrump Indicate if a \\(\\clubsuit\\) occurs after index. If so, keep the time that the first club occurred. censoring variable fullOfHearts The set of all \\(\\heartsuit\\) event start times that occur between index and clubTrump longitudinal data Now let’s express each of these features mathematically. 5.1 2spade1heart Let’s define a few more functions that operate on \\(w\\) and \\(\\Xi\\). Definition Mapping Description \\(any(W) = \\begin{cases} W \\neq \\emptyset &amp; TRUE \\\\ else &amp; FALSE \\end{cases}\\) \\(any : \\mathcal{W} \\mapsto \\mathbb{B}\\) Is \\(W\\) empty? ANY &lt;- function(x) length(x) &gt; 0 compare_head_to_tail_cast &lt;- function(compareFUN){ force(compareFUN) f &lt;- function(el){ switch( EXPR = as.character(length(el)), &quot;0&quot; = list(), &quot;1&quot; = list(FALSE), Map(function(x, h) { compareFUN(x, h = h) }, el[-1L], h = el[1L]) %&gt;% Reduce(`|`, .) %&gt;% list() %&gt;% append(f(el[-1L]))) } f } compare_function_cast &lt;- function(relation, bound){ function(x, h){ relation( s(x) - s(h), bound) } } t2spade1heart &lt;- function(W){ a_cast(c(&quot;interval&quot;, &quot;a&quot;)) %&gt;% p_cast(`&lt;`, index(W)) %&gt;% l_cast() %&gt;% { {.(Lsuit_cast(&quot;spade&quot;)(W))} %&gt;% { w &lt;- . compare_function_cast(`&gt;=`, 3) %&gt;% compare_head_to_tail_cast() %&gt;% { w[unlist(.(w))] } } %&gt;% ANY() || {.(Lsuit_cast(&quot;club&quot;)(W))} %&gt;% ANY() } } # No clubs before index W1 &lt;- W[-7] W3 &lt;- W2 &lt;- W1 W2[[6]] &lt;- event(interval = interval(a = 17L, b = 17L), context = context(suit = suit(&quot;spade&quot;), value = &quot;2&quot;)) W3[[5]] &lt;- event(interval = interval(a = 8L, b = 8L), context = context(suit = suit(&quot;spade&quot;), value = &quot;2&quot;)) t2spade1heart(W) ## [1] TRUE t2spade1heart(W1) ## [1] TRUE t2spade1heart(W2) ## [1] TRUE t2spade1heart(W3) ## [1] TRUE This code will certainly be cleaned up, a key point is that the function is composed of a pattern: filter W -&gt; apply function: clubs spades | | before index | | id has gaps &gt; 3 | | any any \\ / or The key this project is identifying and exploiting such patterns. Towards a configuration: filters: A: starts of clubs before index B: starts of spades with a pairwise distance of starts &gt; 3 before index features: id: any A or any B 5.2 foreverDiamonds any periods of diamonds \\[ \\begin{aligned} \\mathsf{L}^{\\diamondsuit}(W) &amp;= \\{ w | w \\in \\mathsf{L}(W&#39;, \\mathsf{P}^c(A_t, = \\diamondsuit) \\} \\\\ \\text{scangap} &amp;= f(B) = \\{(a&#39;, b&#39;) | (a, b) \\in B, \\,\\, a&#39; = \\text{if } x_{i} \\leq y_{i - 1} + c \\text{ then } x_{i - 1} \\text{ else } x_{i} , b&#39; = \\text{if } y_{i} \\leq y_{i - 1} \\text{ then } y_{i - 1} \\text{ else } y_{i}, \\forall i = 2, \\dots, n \\} \\\\ \\text{periods} &amp;= g(B) = \\{(a, b&#39;) | (a, b) \\in f(B), \\,\\, b&#39; = max(b) \\,\\, \\forall a_i = a_j \\} \\\\ \\text{pdperiods} &amp;= h(B, pd) = \\{ (a, b) | (a, b) \\in g(B), \\,\\, a &gt; \\mathsf{a}_s(pd), \\, b &lt; \\mathsf{a}_e(pd) \\} \\\\ \\text{gaps} &amp;= d(B, pd) = \\{(a, b) | (a, b) \\in B, TODO \\} \\\\ \\text{foreverDiamonds}(W, \\text{index}) &amp;= \\{\\text{if } \\{x | (a, b) \\in d(h(A_{se}(\\mathsf{L}^{\\diamondsuit}), (-25, index)), x = b - a, x &gt; 10 \\} = \\emptyset \\text{ FALSE} \\text { else } \\text{TRUE} \\} \\\\ \\end{aligned} \\] Let’s look at the \\(\\text{scangap}\\) function and the patterns it can be composed of. First, we have a function performing the nuts and bolts of the set comprehension (e.g., \\(\\text{if } x_{i} \\leq y_{i - 1} + c \\text{ then } x_{i - 1} \\text{ else } x_{i}\\)), which be somewhat kludglily patterned as: check_gap_cast &lt;- function(cc = 0, pos = c(1, 2, 1, 1)) { function(a, b){ if (b[pos[1]] &lt;= (a[pos[2]] + cc)) a[pos[3]] else b[pos[4]] } } So that check_gap_cast(cc = 10, pos = c(1, 2, 1, 1)) yields \\(f(x, y) = \\text{if } x_{i} \\leq y_{i - 1} + 10 \\text{ then } x_{i - 1} \\text{ else } x_{i}\\) and check_gap_cast(cc = 0, pos = c(2, 2, 2, 2)) yields \\(f&#39;(x, y) = \\text{if } y_{i} \\leq y_{i - 1} \\text{ then } y_{i - 1} \\text{ else } y_{i}\\). Then we can apply that pattern to create the scangap function. scangap_cast &lt;- function(cc){ function(l){ Reduce( f = function(x, y){ c(check_gap_cast(cc, c(1, 2, 1, 1))(x, y), check_gap_cast(0, c(2, 2, 2, 2))(x, y)) }, x = l, accumulate = TRUE) } } scangap_cast(10)(head(Wdt$xy)) ## [[1]] ## [1] 8 18 ## ## [[2]] ## [1] 8 18 ## ## [[3]] ## [1] 8 24 ## ## [[4]] ## [1] 8 38 ## ## [[5]] ## [1] 8 38 ## ## [[6]] ## [1] 8 46 In summary, scangap return a set of tuples the same length as the input \\(W\\), where the start and end of each \\(w_i \\in W\\) have been updated depending on \\(w_{i - 1}\\) extending the period until a time gap of 10 units occurs. Now, we can identify which of those periods are the non overlapping periods by scanning the modified periods from the right, accumulating an indicator of whether each period is the longest segment of a period; then we can use set (list) comprehension to filter to the unique periods. For example, (warning: this is klunky and could be cleaned up), but in R: # Finds the longest non-overlapping periods scan_periods_cast &lt;- function(cc){ function(l){ Map( function(x) as.logical(x[3]), Reduce( f = function(a, b) c(a, (a[2] + cc &lt;= b[1]) * 1), x = l[-length(l)], init = c(l[[length(l)]], 1), accumulate = TRUE, right = TRUE) ) } } period_cast &lt;- function(cc){ ff &lt;- scan_periods_cast(cc) gg &lt;- scangap_cast(cc) function(l){ gg(l)[unlist(ff(gg(l)))] } } period_cast(10)(Wdt$xy) ## [[1]] ## [1] 8 100 period_cast(10)(head(Wdt$xy)) ## [[1]] ## [1] 8 46 Now we have need a function that limits our periods to just those that overlap another period \\(pd\\) (e.g. a lookback period). This is the \\(pdperiod\\) function. pdperiod &lt;- function(l, p){ Filter( f = function(z) { !(p[2] &lt; z[1]) &amp;&amp; !(p[1] &gt; z[2]) }, x = l ) } period_cast(10)(Wdt$xy) %&gt;% pdperiod(p = c(4, 10)) ## [[1]] ## [1] 8 100 period_cast(10)(Wdt$xy) %&gt;% pdperiod(p = c(-10, 10)) ## [[1]] ## [1] 8 100 period_cast(10)(Wdt$xy) %&gt;% pdperiod(p = c(-10, 90)) ## [[1]] ## [1] 8 100 # Define a couple of helper function s &lt;- function(p) p[1] e &lt;- function(p) p[2] h &lt;- function(p1, p2){ if(s(p2) &lt; s(p1) &amp;&amp; e(p2) &lt;= e(p1)){ list(c(e(p2), e(p1))) } else if(s(p1) &lt;= s(p2) &amp;&amp; e(p1) &lt; e(p2)){ list(c(s(p1), s(p2))) } else if(s(p1) &lt;= s(p2) &amp;&amp; e(p2) &lt;= e(p1)){ list(c(s(p1), s(p2)), c(e(p2), e(p1))) } else { NULL } } f &lt;- function(l, p2){ out &lt;- l[-length(l)] p1 &lt;- l[[length(l)]] hold &lt;- h(p1, p2) append(out, hold) } h(c(1, 10), c(0, 5)) h(c(1, 10), c(2, 5)) h(c(1, 10), c(0, 11)) pds &lt;- list( c(2, 5), c(10, 15), c(16, 17) ) gap_cast &lt;- function(pd){ function(periods){ Reduce(f, periods, init = list(pd)) } } shift_period &lt;- function(p, x){ x + p } lookback &lt;- shift_period(c(-25, 0), index(W)) preindex_gaps &lt;- gap_cast(lookback) # period_cast(10)(Wdt$xy) %&gt;% # clip_period(p = lookback) # # h(lookback, c(1, 67)) # %&gt;% # Reduce(f, ., init = list(lookback)) Now let’s build foreverDiamonds Ldiamond &lt;- Lsuit_cast(&quot;diamond&quot;) foreverDiamonds &lt;- function(W){ Ldiamond(W) %&gt;% A_prd %&gt;% { period_cast(10)(.) } %&gt;% preindex_gaps %&gt;% { length(.) &gt; 0} } foreverDiamonds(W) Note that another pattern emerged! Lw is exactly the same pattern as the first part of index! 5.3 flush \\(\\text{flush}(W, \\text{index})\\) 5.4 clubTrump \\(\\text{clubTrump}(W, \\text{index})\\) 5.5 fullOfHearts "],["specifications.html", "Chapter 6 Specifications", " Chapter 6 Specifications The translator between and analysis plan and code that maps a population to cohort.. "],["working-example.html", "Chapter 7 Working example", " Chapter 7 Working example TODO "]]
